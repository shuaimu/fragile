//! C++ virtual function dispatch support.

use core::ffi::c_void;

/// A vtable entry (function pointer).
pub type VtableEntry = unsafe extern "C" fn(*mut c_void);

/// A C++ vtable structure.
///
/// This is the layout of a vtable as generated by the compiler.
/// Each virtual function has an entry in the vtable.
/// Virtual function entries (flexible array) follow this header.
#[repr(C)]
pub struct Vtable {
    /// Offset to top of object (for multiple inheritance)
    pub offset_to_top: isize,
    /// Pointer to type info (RTTI)
    pub type_info: *const c_void,
}

/// Get a virtual function pointer from an object's vtable.
///
/// # Safety
/// - `obj` must be a valid pointer to a C++ object with a vtable
/// - `index` must be a valid vtable index
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_vfunc_get(
    obj: *const c_void,
    index: usize,
) -> VtableEntry {
    // First pointer in object is vtable pointer
    let vtable_ptr = *(obj as *const *const VtableEntry);

    // Index into vtable
    *vtable_ptr.add(index)
}

/// Call a virtual function with no arguments.
///
/// # Safety
/// Same as fragile_rt_vfunc_get.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_vcall_0(
    obj: *mut c_void,
    index: usize,
) {
    let func = fragile_rt_vfunc_get(obj, index);
    func(obj);
}

/// Call a virtual function with one argument.
///
/// # Safety
/// Same as fragile_rt_vfunc_get.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_vcall_1(
    obj: *mut c_void,
    index: usize,
    arg1: *mut c_void,
) {
    type VFunc1 = unsafe extern "C" fn(*mut c_void, *mut c_void);

    let func = fragile_rt_vfunc_get(obj, index);
    let func: VFunc1 = core::mem::transmute(func);
    func(obj, arg1);
}

/// Call a virtual function with two arguments.
///
/// # Safety
/// Same as fragile_rt_vfunc_get.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_vcall_2(
    obj: *mut c_void,
    index: usize,
    arg1: *mut c_void,
    arg2: *mut c_void,
) {
    type VFunc2 = unsafe extern "C" fn(*mut c_void, *mut c_void, *mut c_void);

    let func = fragile_rt_vfunc_get(obj, index);
    let func: VFunc2 = core::mem::transmute(func);
    func(obj, arg1, arg2);
}

/// Get the type info from an object's vtable (for dynamic_cast).
///
/// # Safety
/// `obj` must be a valid pointer to a C++ object with a vtable.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_get_type_info(obj: *const c_void) -> *const c_void {
    // First pointer in object is vtable pointer
    let vtable_ptr = *(obj as *const *const c_void);

    // Type info is at offset -1 from vtable start (before function pointers)
    let vtable = vtable_ptr as *const Vtable;
    (*vtable.sub(1)).type_info
}

/// Dynamic cast implementation.
///
/// Attempts to cast from one type to another, checking RTTI.
/// Returns null if the cast is invalid.
///
/// # Safety
/// `obj` must be a valid pointer to a C++ object with RTTI.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_dynamic_cast(
    obj: *mut c_void,
    _src_type_info: *const c_void,
    dst_type_info: *const c_void,
) -> *mut c_void {
    if obj.is_null() {
        return core::ptr::null_mut();
    }

    // Get the actual type info from the object
    let actual_type_info = fragile_rt_get_type_info(obj);

    // Simple check: only allow cast if types match exactly
    // Real implementation would walk the inheritance hierarchy
    if actual_type_info == dst_type_info {
        obj
    } else {
        core::ptr::null_mut()
    }
}

/// Static cast with offset adjustment (for multiple inheritance).
///
/// # Safety
/// Caller must ensure the cast is valid.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_static_cast(
    obj: *mut c_void,
    offset: isize,
) -> *mut c_void {
    if obj.is_null() {
        return core::ptr::null_mut();
    }

    (obj as *mut u8).offset(offset) as *mut c_void
}

/// Initialize a vtable pointer in an object.
///
/// Called during object construction to set up the vtable.
///
/// # Safety
/// `obj` must be a valid pointer with space for a vtable pointer.
#[no_mangle]
pub unsafe extern "C" fn fragile_rt_init_vtable(
    obj: *mut c_void,
    vtable: *const VtableEntry,
) {
    let vtable_slot = obj as *mut *const VtableEntry;
    *vtable_slot = vtable;
}
