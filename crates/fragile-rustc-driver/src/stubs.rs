//! Generate Rust stub declarations for C++ code.

use fragile_clang::{CppExtern, CppFunction, CppModule, CppStruct};

/// Generate Rust stub code for C++ declarations.
///
/// This generates `extern "C"` blocks and struct definitions that
/// allow Rust code to reference C++ functions and types.
pub fn generate_rust_stubs(modules: &[CppModule]) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated by fragile-rustc-driver\n");
    output.push_str("// Do not edit manually\n\n");

    // Generate struct definitions
    for module in modules {
        for struct_def in &module.structs {
            output.push_str(&generate_struct_stub(struct_def));
            output.push('\n');
        }
    }

    // Generate extern "C" block for functions
    output.push_str("extern \"C\" {\n");

    for module in modules {
        // External declarations (no body)
        for extern_decl in &module.externs {
            output.push_str(&generate_extern_stub(extern_decl));
        }

        // Function definitions (will be provided via MIR injection)
        for func in &module.functions {
            output.push_str(&generate_function_stub(func));
        }
    }

    output.push_str("}\n");

    output
}

/// Generate a Rust struct definition for a C++ struct.
fn generate_struct_stub(struct_def: &CppStruct) -> String {
    use fragile_clang::AccessSpecifier;

    let mut output = String::new();

    output.push_str("#[repr(C)]\n");
    output.push_str(&format!("pub struct {} {{\n", struct_def.name));

    // Generate non-static fields
    for field in &struct_def.fields {
        let rust_type = field.ty.to_rust_type_str();
        // Only public fields get pub visibility in Rust
        let visibility = match field.access {
            AccessSpecifier::Public => "pub ",
            AccessSpecifier::Private | AccessSpecifier::Protected => "",
        };
        output.push_str(&format!("    {}{}: {},\n", visibility, field.name, rust_type));
    }

    output.push_str("}\n");

    // Generate static fields as associated constants (if any)
    // Note: Static members need separate handling in C++

    output
}

/// Generate a Rust extern declaration for a C++ extern.
fn generate_extern_stub(extern_decl: &CppExtern) -> String {
    let mut output = String::new();

    let params: Vec<String> = extern_decl
        .params
        .iter()
        .map(|(name, ty)| format!("{}: {}", name, ty.to_rust_type_str()))
        .collect();

    let return_type = extern_decl.return_type.to_rust_type_str();

    output.push_str(&format!(
        "    fn {}({}) -> {};\n",
        extern_decl.display_name,
        params.join(", "),
        return_type
    ));

    output
}

/// Generate a Rust extern declaration for a C++ function.
///
/// The actual implementation will be provided via MIR injection,
/// but we need the declaration for Rust to be able to call it.
fn generate_function_stub(func: &CppFunction) -> String {
    let mut output = String::new();

    let params: Vec<String> = func
        .params
        .iter()
        .map(|(name, ty)| format!("{}: {}", name, ty.to_rust_type_str()))
        .collect();

    let return_type = func.return_type.to_rust_type_str();

    // Add a marker attribute so we can identify C++ functions
    output.push_str(&format!(
        "    #[link_name = \"{}\"]\n",
        func.mangled_name
    ));
    output.push_str(&format!(
        "    fn {}({}) -> {};\n",
        func.display_name,
        params.join(", "),
        return_type
    ));

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use fragile_clang::CppType;
    use fragile_clang::MirBody;

    #[test]
    fn test_generate_function_stub() {
        let func = CppFunction {
            mangled_name: "_Z3addii".to_string(),
            display_name: "add".to_string(),
            namespace: Vec::new(),
            params: vec![
                ("a".to_string(), CppType::int()),
                ("b".to_string(), CppType::int()),
            ],
            return_type: CppType::int(),
            mir_body: MirBody::new(),
        };

        let stub = generate_function_stub(&func);

        assert!(stub.contains("fn add(a: i32, b: i32) -> i32"));
        assert!(stub.contains("#[link_name = \"_Z3addii\"]"));
    }

    #[test]
    fn test_generate_struct_stub() {
        use fragile_clang::{AccessSpecifier, CppField};

        let struct_def = CppStruct {
            name: "Point".to_string(),
            is_class: false,
            namespace: Vec::new(),
            bases: vec![],
            fields: vec![
                CppField { name: "x".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
                CppField { name: "y".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
            ],
            static_fields: vec![],
            constructors: vec![],
            destructor: None,
            methods: vec![],
            member_templates: vec![],
            friends: vec![],
        };

        let stub = generate_struct_stub(&struct_def);

        assert!(stub.contains("#[repr(C)]"));
        assert!(stub.contains("pub struct Point"));
        assert!(stub.contains("pub x: i32"));
        assert!(stub.contains("pub y: i32"));
    }

    #[test]
    fn test_generate_struct_stub_with_private_fields() {
        use fragile_clang::{AccessSpecifier, CppField};

        let struct_def = CppStruct {
            name: "MyClass".to_string(),
            is_class: true,
            namespace: Vec::new(),
            bases: vec![],
            fields: vec![
                CppField { name: "public_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
                CppField { name: "private_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Private },
                CppField { name: "protected_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Protected },
            ],
            static_fields: vec![],
            constructors: vec![],
            destructor: None,
            methods: vec![],
            member_templates: vec![],
            friends: vec![],
        };

        let stub = generate_struct_stub(&struct_def);

        assert!(stub.contains("pub public_field: i32"));
        assert!(stub.contains("private_field: i32"));
        assert!(!stub.contains("pub private_field"));
        assert!(stub.contains("protected_field: i32"));
        assert!(!stub.contains("pub protected_field"));
    }

    #[test]
    fn test_generate_rust_stubs() {
        let mut module = CppModule::new();
        module.functions.push(CppFunction {
            mangled_name: "_Z3addii".to_string(),
            display_name: "add".to_string(),
            namespace: Vec::new(),
            params: vec![
                ("a".to_string(), CppType::int()),
                ("b".to_string(), CppType::int()),
            ],
            return_type: CppType::int(),
            mir_body: MirBody::new(),
        });

        let stubs = generate_rust_stubs(&[module]);

        assert!(stubs.contains("extern \"C\""));
        assert!(stubs.contains("fn add"));
    }
}
