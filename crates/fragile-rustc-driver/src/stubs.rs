//! Generate Rust stub declarations for C++ code.
//!
//! ## MIR Injection Strategy
//!
//! To enable MIR injection, we generate **regular Rust functions** (not `extern "C"`).
//! This is because `extern "C"` declarations create ForeignItems which don't have
//! MIR bodies - rustc's `mir_built` query is never called for them.
//!
//! Instead, we generate functions with stub bodies that will be replaced by
//! injected C++ MIR at compile time:
//!
//! ```rust,ignore
//! #[doc(hidden)]
//! #[fragile_cpp = "_Z7add_cppii"]
//! #[no_mangle]
//! pub extern "C" fn add_cpp(a: i32, b: i32) -> i32 {
//!     unreachable!("Fragile: MIR injection placeholder")
//! }
//! ```
//!
//! The `#[fragile_cpp = "..."]` attribute stores the C++ mangled name, which
//! allows the `mir_built` query override to identify and replace these functions.

use fragile_clang::{CppExtern, CppFunction, CppModule, CppStruct};

/// Generate Rust stub code for C++ declarations.
///
/// This generates regular Rust functions with stub bodies and struct definitions.
/// The function bodies are placeholders that will be replaced by MIR injection.
///
/// For backwards compatibility with tests that rely on the old extern "C" style,
/// use `generate_rust_stubs_extern` instead.
pub fn generate_rust_stubs(modules: &[CppModule]) -> String {
    generate_rust_stubs_mir_injection(modules)
}

/// Generate Rust stubs using regular functions for MIR injection.
///
/// This is the new preferred method that enables MIR injection by generating
/// regular Rust functions instead of extern "C" declarations.
pub fn generate_rust_stubs_mir_injection(modules: &[CppModule]) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated by fragile-rustc-driver\n");
    output.push_str("// MIR injection stubs - bodies will be replaced at compile time\n\n");

    // Allow the fragile_cpp attribute
    output.push_str("#![allow(dead_code)]\n");
    output.push_str("#![allow(unused_variables)]\n\n");

    // Generate struct definitions
    for module in modules {
        for struct_def in &module.structs {
            output.push_str(&generate_struct_stub(struct_def));
            output.push('\n');
        }
    }

    // Generate function stubs with bodies for MIR injection
    for module in modules {
        // External declarations (still use extern "C" - these are actual external functions)
        if !module.externs.is_empty() {
            output.push_str("extern \"C\" {\n");
            for extern_decl in &module.externs {
                output.push_str(&generate_extern_stub(extern_decl));
            }
            output.push_str("}\n\n");
        }

        // Function definitions (regular functions for MIR injection)
        for func in &module.functions {
            output.push_str(&generate_function_stub_mir_injection(func));
            output.push('\n');
        }
    }

    output
}

/// Generate Rust stubs using extern "C" declarations (legacy method).
///
/// This method generates extern "C" declarations without bodies.
/// It's kept for backwards compatibility but does NOT support MIR injection.
pub fn generate_rust_stubs_extern(modules: &[CppModule]) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated by fragile-rustc-driver\n");
    output.push_str("// Legacy extern stubs - requires linking with C++ objects\n\n");

    // Generate struct definitions
    for module in modules {
        for struct_def in &module.structs {
            output.push_str(&generate_struct_stub(struct_def));
            output.push('\n');
        }
    }

    // Generate extern "C" block for functions
    output.push_str("extern \"C\" {\n");

    for module in modules {
        // External declarations (no body)
        for extern_decl in &module.externs {
            output.push_str(&generate_extern_stub(extern_decl));
        }

        // Function definitions (extern declarations)
        for func in &module.functions {
            output.push_str(&generate_function_stub_extern(func));
        }
    }

    output.push_str("}\n");

    output
}

/// Generate a Rust struct definition for a C++ struct.
fn generate_struct_stub(struct_def: &CppStruct) -> String {
    use fragile_clang::AccessSpecifier;

    let mut output = String::new();

    output.push_str("#[repr(C)]\n");
    output.push_str(&format!("pub struct {} {{\n", struct_def.name));

    // Generate non-static fields
    for field in &struct_def.fields {
        let rust_type = field.ty.to_rust_type_str();
        // Only public fields get pub visibility in Rust
        let visibility = match field.access {
            AccessSpecifier::Public => "pub ",
            AccessSpecifier::Private | AccessSpecifier::Protected => "",
        };
        output.push_str(&format!("    {}{}: {},\n", visibility, field.name, rust_type));
    }

    output.push_str("}\n");

    // Generate static fields as associated constants (if any)
    // Note: Static members need separate handling in C++

    output
}

/// Generate a Rust extern declaration for a C++ extern.
fn generate_extern_stub(extern_decl: &CppExtern) -> String {
    let mut output = String::new();

    let params: Vec<String> = extern_decl
        .params
        .iter()
        .map(|(name, ty)| format!("{}: {}", name, ty.to_rust_type_str()))
        .collect();

    let return_type = extern_decl.return_type.to_rust_type_str();

    output.push_str(&format!(
        "    fn {}({}) -> {};\n",
        extern_decl.display_name,
        params.join(", "),
        return_type
    ));

    output
}

/// Generate a regular Rust function with stub body for MIR injection.
///
/// The stub body will be replaced by the actual C++ MIR at compile time
/// via the `mir_built` query override.
fn generate_function_stub_mir_injection(func: &CppFunction) -> String {
    let mut output = String::new();

    let params: Vec<String> = func
        .params
        .iter()
        .map(|(name, ty)| format!("{}: {}", name, ty.to_rust_type_str()))
        .collect();

    let return_type = func.return_type.to_rust_type_str();

    // Add doc attribute with mangled name for identification by mir_built override
    // Using #[doc(hidden)] to hide from docs but still accessible
    output.push_str(&format!(
        "/// @fragile_cpp_mangled: {}\n",
        func.mangled_name
    ));

    // Export with the C++ mangled name for proper linking
    output.push_str(&format!(
        "#[export_name = \"{}\"]\n",
        func.mangled_name
    ));

    // Use C ABI for compatibility
    output.push_str(&format!(
        "pub extern \"C\" fn {}({}) -> {} {{\n",
        func.display_name,
        params.join(", "),
        return_type
    ));

    // Stub body - will be replaced by MIR injection
    // Use unreachable!() as it clearly indicates this code should never run
    output.push_str("    // Stub body - replaced by MIR injection at compile time\n");
    output.push_str("    unreachable!(\"Fragile: C++ MIR should be injected\")\n");
    output.push_str("}\n");

    output
}

/// Generate a Rust extern declaration for a C++ function (legacy method).
///
/// This generates an extern "C" declaration without a body.
/// It requires the C++ code to be compiled separately and linked.
fn generate_function_stub_extern(func: &CppFunction) -> String {
    let mut output = String::new();

    let params: Vec<String> = func
        .params
        .iter()
        .map(|(name, ty)| format!("{}: {}", name, ty.to_rust_type_str()))
        .collect();

    let return_type = func.return_type.to_rust_type_str();

    // Add a marker attribute so we can identify C++ functions
    output.push_str(&format!(
        "    #[link_name = \"{}\"]\n",
        func.mangled_name
    ));
    output.push_str(&format!(
        "    fn {}({}) -> {};\n",
        func.display_name,
        params.join(", "),
        return_type
    ));

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use fragile_clang::CppType;
    use fragile_clang::MirBody;

    #[test]
    fn test_generate_function_stub() {
        let func = CppFunction {
            mangled_name: "_Z3addii".to_string(),
            display_name: "add".to_string(),
            namespace: Vec::new(),
            params: vec![
                ("a".to_string(), CppType::int()),
                ("b".to_string(), CppType::int()),
            ],
            return_type: CppType::int(),
            is_noexcept: false,
            mir_body: MirBody::new(),
        };

        // Test MIR injection stubs (new default)
        let stub = generate_function_stub_mir_injection(&func);
        assert!(stub.contains("pub extern \"C\" fn add(a: i32, b: i32) -> i32"));
        assert!(stub.contains("#[export_name = \"_Z3addii\"]"));
        assert!(stub.contains("@fragile_cpp_mangled: _Z3addii"));
        assert!(stub.contains("unreachable!"));

        // Test legacy extern stubs
        let legacy_stub = generate_function_stub_extern(&func);
        assert!(legacy_stub.contains("fn add(a: i32, b: i32) -> i32"));
        assert!(legacy_stub.contains("#[link_name = \"_Z3addii\"]"));
    }

    #[test]
    fn test_generate_struct_stub() {
        use fragile_clang::{AccessSpecifier, CppField};

        let struct_def = CppStruct {
            name: "Point".to_string(),
            is_class: false,
            namespace: Vec::new(),
            bases: vec![],
            fields: vec![
                CppField { name: "x".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
                CppField { name: "y".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
            ],
            static_fields: vec![],
            constructors: vec![],
            destructor: None,
            methods: vec![],
            member_templates: vec![],
            friends: vec![],
        };

        let stub = generate_struct_stub(&struct_def);

        assert!(stub.contains("#[repr(C)]"));
        assert!(stub.contains("pub struct Point"));
        assert!(stub.contains("pub x: i32"));
        assert!(stub.contains("pub y: i32"));
    }

    #[test]
    fn test_generate_struct_stub_with_private_fields() {
        use fragile_clang::{AccessSpecifier, CppField};

        let struct_def = CppStruct {
            name: "MyClass".to_string(),
            is_class: true,
            namespace: Vec::new(),
            bases: vec![],
            fields: vec![
                CppField { name: "public_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Public },
                CppField { name: "private_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Private },
                CppField { name: "protected_field".to_string(), ty: CppType::int(), access: AccessSpecifier::Protected },
            ],
            static_fields: vec![],
            constructors: vec![],
            destructor: None,
            methods: vec![],
            member_templates: vec![],
            friends: vec![],
        };

        let stub = generate_struct_stub(&struct_def);

        assert!(stub.contains("pub public_field: i32"));
        assert!(stub.contains("private_field: i32"));
        assert!(!stub.contains("pub private_field"));
        assert!(stub.contains("protected_field: i32"));
        assert!(!stub.contains("pub protected_field"));
    }

    fn make_test_module() -> CppModule {
        let mut module = CppModule::new();
        module.functions.push(CppFunction {
            mangled_name: "_Z3addii".to_string(),
            display_name: "add".to_string(),
            namespace: Vec::new(),
            params: vec![
                ("a".to_string(), CppType::int()),
                ("b".to_string(), CppType::int()),
            ],
            return_type: CppType::int(),
            is_noexcept: false,
            mir_body: MirBody::new(),
        });
        module
    }

    #[test]
    fn test_generate_rust_stubs() {
        // Test MIR injection stubs (default)
        let stubs = generate_rust_stubs(&[make_test_module()]);
        assert!(stubs.contains("pub extern \"C\" fn add"));
        assert!(stubs.contains("#[export_name = \"_Z3addii\"]"));
        assert!(stubs.contains("unreachable!"));
    }

    #[test]
    fn test_generate_rust_stubs_extern() {
        // Test legacy extern stubs
        let legacy_stubs = generate_rust_stubs_extern(&[make_test_module()]);
        assert!(legacy_stubs.contains("extern \"C\""));
        assert!(legacy_stubs.contains("fn add"));
        assert!(legacy_stubs.contains("#[link_name = \"_Z3addii\"]"));
    }
}
