// Minimal mutex stub for fragile parsing
#ifndef _FRAGILE_MUTEX_
#define _FRAGILE_MUTEX_

namespace std {

// Basic mutex stub
class mutex {
public:
    mutex() = default;
    ~mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock() {}
    void unlock() {}
    bool try_lock() { return true; }
};

// Recursive mutex
class recursive_mutex {
public:
    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock() {}
    void unlock() {}
    bool try_lock() { return true; }
};

// Tag types (must be before lock_guard/unique_lock)
struct adopt_lock_t { explicit adopt_lock_t() = default; };
struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };

inline constexpr adopt_lock_t adopt_lock{};
inline constexpr defer_lock_t defer_lock{};
inline constexpr try_to_lock_t try_to_lock{};

// Lock guard
template<typename Mutex>
class lock_guard {
public:
    using mutex_type = Mutex;

    explicit lock_guard(mutex_type& m) : mtx_(m) { mtx_.lock(); }
    lock_guard(mutex_type& m, adopt_lock_t) : mtx_(m) {}
    ~lock_guard() { mtx_.unlock(); }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    mutex_type& mtx_;
};

// Unique lock
template<typename Mutex>
class unique_lock {
public:
    using mutex_type = Mutex;

    unique_lock() noexcept : mtx_(nullptr), owns_(false) {}
    explicit unique_lock(mutex_type& m) : mtx_(&m), owns_(true) { mtx_->lock(); }
    ~unique_lock() { if (owns_) mtx_->unlock(); }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    unique_lock(unique_lock&& other) noexcept
        : mtx_(other.mtx_), owns_(other.owns_) {
        other.mtx_ = nullptr;
        other.owns_ = false;
    }

    unique_lock& operator=(unique_lock&& other) noexcept {
        if (owns_) mtx_->unlock();
        mtx_ = other.mtx_;
        owns_ = other.owns_;
        other.mtx_ = nullptr;
        other.owns_ = false;
        return *this;
    }

    void lock() { mtx_->lock(); owns_ = true; }
    void unlock() { mtx_->unlock(); owns_ = false; }
    bool try_lock() { owns_ = mtx_->try_lock(); return owns_; }

    mutex_type* mutex() const noexcept { return mtx_; }
    bool owns_lock() const noexcept { return owns_; }
    explicit operator bool() const noexcept { return owns_; }

private:
    mutex_type* mtx_;
    bool owns_;
};

} // namespace std

#endif // _FRAGILE_MUTEX_
