// Minimal mutex stub for fragile parsing
#ifndef _FRAGILE_MUTEX_
#define _FRAGILE_MUTEX_

// Include thread for std::this_thread (commonly used together)
#include "thread"

namespace std {

// Basic mutex stub
class mutex {
public:
    mutex() = default;
    ~mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock() {}
    void unlock() {}
    bool try_lock() { return true; }
};

// Recursive mutex
class recursive_mutex {
public:
    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock() {}
    void unlock() {}
    bool try_lock() { return true; }
};

// Tag types (must be before lock_guard/unique_lock)
struct adopt_lock_t { explicit adopt_lock_t() = default; };
struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };

inline constexpr adopt_lock_t adopt_lock{};
inline constexpr defer_lock_t defer_lock{};
inline constexpr try_to_lock_t try_to_lock{};

// Lock guard
template<typename Mutex>
class lock_guard {
public:
    using mutex_type = Mutex;

    explicit lock_guard(mutex_type& m) : mtx_(m) { mtx_.lock(); }
    lock_guard(mutex_type& m, adopt_lock_t) : mtx_(m) {}
    ~lock_guard() { mtx_.unlock(); }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    mutex_type& mtx_;
};

// Unique lock
template<typename Mutex>
class unique_lock {
public:
    using mutex_type = Mutex;

    unique_lock() noexcept : mtx_(nullptr), owns_(false) {}
    explicit unique_lock(mutex_type& m) : mtx_(&m), owns_(true) { mtx_->lock(); }
    unique_lock(mutex_type& m, defer_lock_t) noexcept : mtx_(&m), owns_(false) {}
    unique_lock(mutex_type& m, try_to_lock_t) : mtx_(&m), owns_(mtx_->try_lock()) {}
    unique_lock(mutex_type& m, adopt_lock_t) : mtx_(&m), owns_(true) {}
    ~unique_lock() { if (owns_) mtx_->unlock(); }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    unique_lock(unique_lock&& other) noexcept
        : mtx_(other.mtx_), owns_(other.owns_) {
        other.mtx_ = nullptr;
        other.owns_ = false;
    }

    unique_lock& operator=(unique_lock&& other) noexcept {
        if (owns_) mtx_->unlock();
        mtx_ = other.mtx_;
        owns_ = other.owns_;
        other.mtx_ = nullptr;
        other.owns_ = false;
        return *this;
    }

    void lock() { mtx_->lock(); owns_ = true; }
    void unlock() { mtx_->unlock(); owns_ = false; }
    bool try_lock() { owns_ = mtx_->try_lock(); return owns_; }

    mutex_type* mutex() const noexcept { return mtx_; }
    bool owns_lock() const noexcept { return owns_; }
    explicit operator bool() const noexcept { return owns_; }

    mutex_type* release() noexcept {
        mutex_type* ret = mtx_;
        mtx_ = nullptr;
        owns_ = false;
        return ret;
    }

private:
    mutex_type* mtx_;
    bool owns_;
};

// Once flag for one-time initialization
struct once_flag {
    constexpr once_flag() noexcept : state_(0) {}
    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
private:
    int state_;
    template<typename Callable, typename... Args>
    friend void call_once(once_flag& flag, Callable&& f, Args&&... args);
};

// Call once - invoke callable exactly once
template<typename Callable, typename... Args>
void call_once(once_flag& flag, Callable&& f, Args&&... args) {
    if (flag.state_ == 0) {
        f(args...);
        flag.state_ = 1;
    }
}

// Scoped lock (C++17)
template<typename... Mutexes>
class scoped_lock {
public:
    explicit scoped_lock(Mutexes&...) {}
    ~scoped_lock() {}
    scoped_lock(const scoped_lock&) = delete;
    scoped_lock& operator=(const scoped_lock&) = delete;
private:
    // For parsing purposes, this stub just needs to compile
    [[maybe_unused]] int placeholder_;
};

// Single mutex specialization
template<typename Mutex>
class scoped_lock<Mutex> {
public:
    using mutex_type = Mutex;
    explicit scoped_lock(Mutex& m) : guard_(m) {}
    ~scoped_lock() = default;
    scoped_lock(const scoped_lock&) = delete;
    scoped_lock& operator=(const scoped_lock&) = delete;
private:
    lock_guard<Mutex> guard_;
};

} // namespace std

#endif // _FRAGILE_MUTEX_
