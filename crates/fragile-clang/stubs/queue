// Minimal queue stub for fragile parsing
#ifndef _FRAGILE_QUEUE_
#define _FRAGILE_QUEUE_

#include "cstdint"
#include "utility"

namespace std {

template<typename T, typename Container = void>
class queue {
public:
    using value_type = T;
    using size_type = size_t;
    using reference = T&;
    using const_reference = const T&;

    queue() = default;
    queue(const queue&) = default;
    queue(queue&&) = default;
    queue& operator=(const queue&) = default;
    queue& operator=(queue&&) = default;

    // Element access
    reference front() { return data_[0]; }
    const_reference front() const { return data_[0]; }
    reference back() { return data_[size_ - 1]; }
    const_reference back() const { return data_[size_ - 1]; }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }

    // Modifiers
    void push(const T& value) { ++size_; }
    void push(T&& value) { ++size_; }

    template<typename... Args>
    void emplace(Args&&... args) { ++size_; }

    void pop() { --size_; }

    void swap(queue& other) noexcept {
        std::swap(data_, other.data_);
        std::swap(size_, other.size_);
    }

private:
    T* data_ = nullptr;
    size_type size_ = 0;
};

template<typename T, typename Container = void, typename Compare = void>
class priority_queue {
public:
    using value_type = T;
    using size_type = size_t;
    using reference = T&;
    using const_reference = const T&;

    priority_queue() = default;
    priority_queue(const priority_queue&) = default;
    priority_queue(priority_queue&&) = default;
    priority_queue& operator=(const priority_queue&) = default;
    priority_queue& operator=(priority_queue&&) = default;

    // Element access
    const_reference top() const { return data_[0]; }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }

    // Modifiers
    void push(const T& value) { ++size_; }
    void push(T&& value) { ++size_; }

    template<typename... Args>
    void emplace(Args&&... args) { ++size_; }

    void pop() { --size_; }

    void swap(priority_queue& other) noexcept {
        std::swap(data_, other.data_);
        std::swap(size_, other.size_);
    }

private:
    T* data_ = nullptr;
    size_type size_ = 0;
};

} // namespace std

#endif // _FRAGILE_QUEUE_
