// Minimal list stub for fragile parsing
#ifndef _FRAGILE_LIST_
#define _FRAGILE_LIST_

#include "cstdint"
#include "initializer_list"
#include "iterator"  // For std::reverse_iterator

namespace std {

template<typename T, typename Allocator = void>
class list {
private:
    struct node {
        T data;
        node* prev;
        node* next;
        node(const T& d) : data(d), prev(nullptr), next(nullptr) {}
        node(T&& d) : data(static_cast<T&&>(d)), prev(nullptr), next(nullptr) {}
    };

public:
    using value_type = T;
    using size_type = size_t;
    using difference_type = long;
    using reference = T&;
    using const_reference = const T&;

    class iterator {
    public:
        using iterator_category = void;
        using value_type = T;
        using difference_type = long;
        using pointer = T*;
        using reference = T&;

        iterator(node* n = nullptr) : node_(n) {}
        reference operator*() { return node_->data; }
        pointer operator->() { return &(node_->data); }
        iterator& operator++() { node_ = node_->next; return *this; }
        iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }
        iterator& operator--() { node_ = node_->prev; return *this; }
        iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }
        bool operator==(const iterator& other) const { return node_ == other.node_; }
        bool operator!=(const iterator& other) const { return node_ != other.node_; }
    private:
        node* node_;
        friend class list;
    };

    class const_iterator {
    public:
        using iterator_category = void;
        using value_type = T;
        using difference_type = long;
        using pointer = const T*;
        using reference = const T&;

        const_iterator(const node* n = nullptr) : node_(n) {}
        const_iterator(const iterator& it) : node_(it.node_) {}
        reference operator*() const { return node_->data; }
        pointer operator->() const { return &(node_->data); }
        const_iterator& operator++() { node_ = node_->next; return *this; }
        const_iterator operator++(int) { const_iterator tmp = *this; ++(*this); return tmp; }
        const_iterator& operator--() { node_ = node_->prev; return *this; }
        const_iterator operator--(int) { const_iterator tmp = *this; --(*this); return tmp; }
        bool operator==(const const_iterator& other) const { return node_ == other.node_; }
        bool operator!=(const const_iterator& other) const { return node_ != other.node_; }
    private:
        const node* node_;
    };

    // Use std::reverse_iterator for compatibility with helper functions
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // Constructors
    list() : head_(nullptr), tail_(nullptr), size_(0) {}

    list(const list& other) : head_(nullptr), tail_(nullptr), size_(0) {
        for (const auto& v : other) push_back(v);
    }

    list(list&& other) noexcept
        : head_(other.head_), tail_(other.tail_), size_(other.size_) {
        other.head_ = nullptr;
        other.tail_ = nullptr;
        other.size_ = 0;
    }

    list(std::initializer_list<T> init) : head_(nullptr), tail_(nullptr), size_(0) {
        for (const auto& v : init) push_back(v);
    }

    ~list() { clear(); }

    // Assignment
    list& operator=(const list& other) {
        if (this != &other) {
            clear();
            for (const auto& v : other) push_back(v);
        }
        return *this;
    }

    list& operator=(list&& other) noexcept {
        if (this != &other) {
            clear();
            head_ = other.head_;
            tail_ = other.tail_;
            size_ = other.size_;
            other.head_ = nullptr;
            other.tail_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }

    // Iterators
    iterator begin() noexcept { return iterator(head_); }
    const_iterator begin() const noexcept { return const_iterator(head_); }
    const_iterator cbegin() const noexcept { return const_iterator(head_); }
    iterator end() noexcept { return iterator(nullptr); }
    const_iterator end() const noexcept { return const_iterator(nullptr); }
    const_iterator cend() const noexcept { return const_iterator(nullptr); }

    // Reverse iterators (std::reverse_iterator wraps end() for rbegin(), begin() for rend())
    reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
    reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }

    // Element access
    reference front() { return head_->data; }
    const_reference front() const { return head_->data; }
    reference back() { return tail_->data; }
    const_reference back() const { return tail_->data; }

    // Modifiers
    void clear() noexcept {
        while (head_) {
            node* next = head_->next;
            delete head_;
            head_ = next;
        }
        tail_ = nullptr;
        size_ = 0;
    }

    void push_back(const T& value) {
        node* n = new node(value);
        if (tail_) {
            tail_->next = n;
            n->prev = tail_;
            tail_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void push_back(T&& value) {
        node* n = new node(static_cast<T&&>(value));
        if (tail_) {
            tail_->next = n;
            n->prev = tail_;
            tail_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void push_front(const T& value) {
        node* n = new node(value);
        if (head_) {
            head_->prev = n;
            n->next = head_;
            head_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void pop_back() {
        if (tail_) {
            node* prev = tail_->prev;
            delete tail_;
            tail_ = prev;
            if (tail_) tail_->next = nullptr;
            else head_ = nullptr;
            --size_;
        }
    }

    void pop_front() {
        if (head_) {
            node* next = head_->next;
            delete head_;
            head_ = next;
            if (head_) head_->prev = nullptr;
            else tail_ = nullptr;
            --size_;
        }
    }

    template<typename... Args>
    reference emplace_back(Args&&... args) {
        push_back(T(static_cast<Args&&>(args)...));
        return tail_->data;
    }

    iterator erase(const_iterator pos) {
        node* n = const_cast<node*>(pos.node_);
        node* next = n->next;
        if (n->prev) n->prev->next = n->next;
        else head_ = n->next;
        if (n->next) n->next->prev = n->prev;
        else tail_ = n->prev;
        delete n;
        --size_;
        return iterator(next);
    }

    iterator insert(const_iterator pos, const T& value) {
        if (pos.node_ == nullptr) {
            push_back(value);
            return iterator(tail_);
        }
        node* current = const_cast<node*>(pos.node_);
        node* n = new node(value);
        n->next = current;
        n->prev = current->prev;
        if (current->prev) current->prev->next = n;
        else head_ = n;
        current->prev = n;
        ++size_;
        return iterator(n);
    }

    iterator insert(const_iterator pos, T&& value) {
        if (pos.node_ == nullptr) {
            push_back(static_cast<T&&>(value));
            return iterator(tail_);
        }
        node* current = const_cast<node*>(pos.node_);
        node* n = new node(static_cast<T&&>(value));
        n->next = current;
        n->prev = current->prev;
        if (current->prev) current->prev->next = n;
        else head_ = n;
        current->prev = n;
        ++size_;
        return iterator(n);
    }

    // Range insert
    template<typename InputIt>
    iterator insert(const_iterator pos, InputIt first, InputIt last) {
        if (first == last) return iterator(const_cast<node*>(pos.node_));
        iterator result = insert(pos, *first);
        iterator current_pos = result;
        ++current_pos;  // Move to next position
        ++first;
        while (first != last) {
            insert(const_iterator(current_pos.node_), *first);
            ++first;
        }
        return result;
    }

    // List-specific operations
    void sort() {
        // Simple bubble sort for stub
        if (size_ < 2) return;
        bool swapped;
        do {
            swapped = false;
            for (node* n = head_; n && n->next; n = n->next) {
                if (n->next->data < n->data) {
                    T tmp = static_cast<T&&>(n->data);
                    n->data = static_cast<T&&>(n->next->data);
                    n->next->data = static_cast<T&&>(tmp);
                    swapped = true;
                }
            }
        } while (swapped);
    }

    template<typename Compare>
    void sort(Compare comp) {
        // Simple bubble sort for stub
        if (size_ < 2) return;
        bool swapped;
        do {
            swapped = false;
            for (node* n = head_; n && n->next; n = n->next) {
                if (comp(n->next->data, n->data)) {
                    T tmp = static_cast<T&&>(n->data);
                    n->data = static_cast<T&&>(n->next->data);
                    n->next->data = static_cast<T&&>(tmp);
                    swapped = true;
                }
            }
        } while (swapped);
    }

    void remove(const T& value) {
        node* n = head_;
        while (n) {
            node* next = n->next;
            if (n->data == value) {
                if (n->prev) n->prev->next = n->next;
                else head_ = n->next;
                if (n->next) n->next->prev = n->prev;
                else tail_ = n->prev;
                delete n;
                --size_;
            }
            n = next;
        }
    }

    template<typename Predicate>
    void remove_if(Predicate pred) {
        node* n = head_;
        while (n) {
            node* next = n->next;
            if (pred(n->data)) {
                if (n->prev) n->prev->next = n->next;
                else head_ = n->next;
                if (n->next) n->next->prev = n->prev;
                else tail_ = n->prev;
                delete n;
                --size_;
            }
            n = next;
        }
    }

    void unique() {
        if (size_ < 2) return;
        for (node* n = head_; n && n->next; ) {
            if (n->data == n->next->data) {
                node* to_delete = n->next;
                n->next = to_delete->next;
                if (to_delete->next) to_delete->next->prev = n;
                else tail_ = n;
                delete to_delete;
                --size_;
            } else {
                n = n->next;
            }
        }
    }

    void merge(list& other) {
        // Simple merge for sorted lists
        while (!other.empty()) {
            push_back(static_cast<T&&>(other.front()));
            other.pop_front();
        }
        sort();
    }

    void splice(const_iterator pos, list& other) {
        while (!other.empty()) {
            insert(pos, static_cast<T&&>(other.front()));
            other.pop_front();
        }
    }

    // Splice single element from another list
    void splice(const_iterator pos, list& other, const_iterator it) {
        if (it.current == nullptr) return;
        // Extract the node from 'other'
        node* n = const_cast<node*>(it.current);
        // Unlink from other list
        if (n->prev) {
            n->prev->next = n->next;
        } else if (&other != this) {
            // n was head of other
            other.head_ = n->next;
        }
        if (n->next) {
            n->next->prev = n->prev;
        } else if (&other != this) {
            // n was tail of other
            other.tail_ = n->prev;
        }
        if (&other != this) {
            other.size_--;
        }
        // Insert into this list at pos
        node* target = const_cast<node*>(pos.current);
        if (target == nullptr) {
            // Insert at end
            n->prev = tail_;
            n->next = nullptr;
            if (tail_) {
                tail_->next = n;
            } else {
                head_ = n;
            }
            tail_ = n;
        } else {
            n->next = target;
            n->prev = target->prev;
            if (target->prev) {
                target->prev->next = n;
            } else {
                head_ = n;
            }
            target->prev = n;
        }
        if (&other != this) {
            size_++;
        }
    }

    void reverse() {
        if (size_ < 2) return;
        node* current = head_;
        while (current) {
            node* tmp = current->prev;
            current->prev = current->next;
            current->next = tmp;
            current = current->prev;
        }
        node* tmp = head_;
        head_ = tail_;
        tail_ = tmp;
    }

private:
    node* head_;
    node* tail_;
    size_type size_;
};

} // namespace std

#endif // _FRAGILE_LIST_
