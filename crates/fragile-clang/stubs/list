// Minimal list stub for fragile parsing
#ifndef _FRAGILE_LIST_
#define _FRAGILE_LIST_

#include "cstdint"
#include "initializer_list"
#include "iterator"  // For std::reverse_iterator

namespace std {

template<typename T, typename Allocator = void>
class list {
private:
    struct node {
        T data;
        node* prev;
        node* next;
        node(const T& d) : data(d), prev(nullptr), next(nullptr) {}
        node(T&& d) : data(static_cast<T&&>(d)), prev(nullptr), next(nullptr) {}
    };

public:
    using value_type = T;
    using size_type = size_t;
    using difference_type = long;
    using reference = T&;
    using const_reference = const T&;

    class iterator {
    public:
        using iterator_category = void;
        using value_type = T;
        using difference_type = long;
        using pointer = T*;
        using reference = T&;

        iterator(node* n = nullptr) : node_(n) {}
        reference operator*() { return node_->data; }
        pointer operator->() { return &(node_->data); }
        iterator& operator++() { node_ = node_->next; return *this; }
        iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }
        iterator& operator--() { node_ = node_->prev; return *this; }
        iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }
        bool operator==(const iterator& other) const { return node_ == other.node_; }
        bool operator!=(const iterator& other) const { return node_ != other.node_; }
    private:
        node* node_;
        friend class list;
    };

    class const_iterator {
    public:
        using iterator_category = void;
        using value_type = T;
        using difference_type = long;
        using pointer = const T*;
        using reference = const T&;

        const_iterator(const node* n = nullptr) : node_(n) {}
        const_iterator(const iterator& it) : node_(it.node_) {}
        reference operator*() const { return node_->data; }
        pointer operator->() const { return &(node_->data); }
        const_iterator& operator++() { node_ = node_->next; return *this; }
        const_iterator operator++(int) { const_iterator tmp = *this; ++(*this); return tmp; }
        const_iterator& operator--() { node_ = node_->prev; return *this; }
        const_iterator operator--(int) { const_iterator tmp = *this; --(*this); return tmp; }
        bool operator==(const const_iterator& other) const { return node_ == other.node_; }
        bool operator!=(const const_iterator& other) const { return node_ != other.node_; }
    private:
        const node* node_;
    };

    // Use std::reverse_iterator for compatibility with helper functions
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // Constructors
    list() : head_(nullptr), tail_(nullptr), size_(0) {}

    list(const list& other) : head_(nullptr), tail_(nullptr), size_(0) {
        for (const auto& v : other) push_back(v);
    }

    list(list&& other) noexcept
        : head_(other.head_), tail_(other.tail_), size_(other.size_) {
        other.head_ = nullptr;
        other.tail_ = nullptr;
        other.size_ = 0;
    }

    list(std::initializer_list<T> init) : head_(nullptr), tail_(nullptr), size_(0) {
        for (const auto& v : init) push_back(v);
    }

    ~list() { clear(); }

    // Assignment
    list& operator=(const list& other) {
        if (this != &other) {
            clear();
            for (const auto& v : other) push_back(v);
        }
        return *this;
    }

    list& operator=(list&& other) noexcept {
        if (this != &other) {
            clear();
            head_ = other.head_;
            tail_ = other.tail_;
            size_ = other.size_;
            other.head_ = nullptr;
            other.tail_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }

    // Iterators
    iterator begin() noexcept { return iterator(head_); }
    const_iterator begin() const noexcept { return const_iterator(head_); }
    const_iterator cbegin() const noexcept { return const_iterator(head_); }
    iterator end() noexcept { return iterator(nullptr); }
    const_iterator end() const noexcept { return const_iterator(nullptr); }
    const_iterator cend() const noexcept { return const_iterator(nullptr); }

    // Reverse iterators (std::reverse_iterator wraps end() for rbegin(), begin() for rend())
    reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
    reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }

    // Element access
    reference front() { return head_->data; }
    const_reference front() const { return head_->data; }
    reference back() { return tail_->data; }
    const_reference back() const { return tail_->data; }

    // Modifiers
    void clear() noexcept {
        while (head_) {
            node* next = head_->next;
            delete head_;
            head_ = next;
        }
        tail_ = nullptr;
        size_ = 0;
    }

    void push_back(const T& value) {
        node* n = new node(value);
        if (tail_) {
            tail_->next = n;
            n->prev = tail_;
            tail_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void push_back(T&& value) {
        node* n = new node(static_cast<T&&>(value));
        if (tail_) {
            tail_->next = n;
            n->prev = tail_;
            tail_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void push_front(const T& value) {
        node* n = new node(value);
        if (head_) {
            head_->prev = n;
            n->next = head_;
            head_ = n;
        } else {
            head_ = tail_ = n;
        }
        ++size_;
    }

    void pop_back() {
        if (tail_) {
            node* prev = tail_->prev;
            delete tail_;
            tail_ = prev;
            if (tail_) tail_->next = nullptr;
            else head_ = nullptr;
            --size_;
        }
    }

    void pop_front() {
        if (head_) {
            node* next = head_->next;
            delete head_;
            head_ = next;
            if (head_) head_->prev = nullptr;
            else tail_ = nullptr;
            --size_;
        }
    }

    template<typename... Args>
    reference emplace_back(Args&&... args) {
        push_back(T(static_cast<Args&&>(args)...));
        return tail_->data;
    }

    iterator erase(const_iterator pos) {
        node* n = const_cast<node*>(pos.node_);
        node* next = n->next;
        if (n->prev) n->prev->next = n->next;
        else head_ = n->next;
        if (n->next) n->next->prev = n->prev;
        else tail_ = n->prev;
        delete n;
        --size_;
        return iterator(next);
    }

    iterator insert(const_iterator pos, const T& value) {
        if (pos.node_ == nullptr) {
            push_back(value);
            return iterator(tail_);
        }
        node* current = const_cast<node*>(pos.node_);
        node* n = new node(value);
        n->next = current;
        n->prev = current->prev;
        if (current->prev) current->prev->next = n;
        else head_ = n;
        current->prev = n;
        ++size_;
        return iterator(n);
    }

    iterator insert(const_iterator pos, T&& value) {
        if (pos.node_ == nullptr) {
            push_back(static_cast<T&&>(value));
            return iterator(tail_);
        }
        node* current = const_cast<node*>(pos.node_);
        node* n = new node(static_cast<T&&>(value));
        n->next = current;
        n->prev = current->prev;
        if (current->prev) current->prev->next = n;
        else head_ = n;
        current->prev = n;
        ++size_;
        return iterator(n);
    }

    // Range insert
    template<typename InputIt>
    iterator insert(const_iterator pos, InputIt first, InputIt last) {
        if (first == last) return iterator(const_cast<node*>(pos.node_));
        iterator result = insert(pos, *first);
        iterator current_pos = result;
        ++current_pos;  // Move to next position
        ++first;
        while (first != last) {
            insert(const_iterator(current_pos.node_), *first);
            ++first;
        }
        return result;
    }

private:
    node* head_;
    node* tail_;
    size_type size_;
};

} // namespace std

#endif // _FRAGILE_LIST_
