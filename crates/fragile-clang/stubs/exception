// Minimal exception stub for fragile parsing
#ifndef _FRAGILE_EXCEPTION_
#define _FRAGILE_EXCEPTION_

#include "cstddef"

namespace std {

// Base exception class
class exception {
public:
    exception() noexcept = default;
    exception(const exception&) noexcept = default;
    exception& operator=(const exception&) noexcept = default;
    virtual ~exception() noexcept = default;
    virtual const char* what() const noexcept { return "std::exception"; }
};

// Bad exception (thrown by unexpected handlers)
class bad_exception : public exception {
public:
    bad_exception() noexcept = default;
    const char* what() const noexcept override { return "std::bad_exception"; }
};

// Exception pointer type
class exception_ptr {
public:
    exception_ptr() noexcept : ptr_(nullptr) {}
    exception_ptr(nullptr_t) noexcept : ptr_(nullptr) {}
    exception_ptr(const exception_ptr& other) noexcept : ptr_(other.ptr_) {}
    exception_ptr& operator=(const exception_ptr& other) noexcept { ptr_ = other.ptr_; return *this; }
    exception_ptr& operator=(nullptr_t) noexcept { ptr_ = nullptr; return *this; }

    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    friend bool operator==(const exception_ptr& a, const exception_ptr& b) noexcept { return a.ptr_ == b.ptr_; }
    friend bool operator!=(const exception_ptr& a, const exception_ptr& b) noexcept { return a.ptr_ != b.ptr_; }
    friend bool operator==(const exception_ptr& a, nullptr_t) noexcept { return a.ptr_ == nullptr; }
    friend bool operator!=(const exception_ptr& a, nullptr_t) noexcept { return a.ptr_ != nullptr; }

private:
    void* ptr_;
};

// Nested exception class
class nested_exception {
public:
    nested_exception() noexcept : ptr_() {}
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    [[noreturn]] void rethrow_nested() const {}
    exception_ptr nested_ptr() const noexcept { return ptr_; }

private:
    exception_ptr ptr_;
};

// Exception handling functions
exception_ptr current_exception() noexcept;
[[noreturn]] void rethrow_exception(exception_ptr p);

template<typename E>
exception_ptr make_exception_ptr(E e) noexcept {
    (void)e;
    return exception_ptr();
}

template<typename T>
[[noreturn]] void throw_with_nested(T&& t) {
    (void)t;
    while(true) {}
}

template<typename E>
void rethrow_if_nested(const E& e) {
    (void)e;
}

// Terminate and unexpected handlers
using terminate_handler = void(*)();
using unexpected_handler = void(*)();

terminate_handler get_terminate() noexcept;
terminate_handler set_terminate(terminate_handler f) noexcept;
[[noreturn]] void terminate() noexcept;

// uncaught_exception is deprecated in C++17, removed in C++20
// but we provide it for backward compatibility
bool uncaught_exception() noexcept;
int uncaught_exceptions() noexcept;

} // namespace std

#endif // _FRAGILE_EXCEPTION_
