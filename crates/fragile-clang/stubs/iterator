// Minimal iterator stub for fragile parsing
#ifndef _FRAGILE_ITERATOR_
#define _FRAGILE_ITERATOR_

#include "cstdint"

namespace std {

// Iterator categories
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
struct contiguous_iterator_tag : public random_access_iterator_tag {};

// Deprecated std::iterator base class (removed in C++17, but needed for legacy code)
template<
    typename Category,
    typename T,
    typename Distance = long,
    typename Pointer = T*,
    typename Reference = T&
>
struct iterator {
    using iterator_category = Category;
    using value_type = T;
    using difference_type = Distance;
    using pointer = Pointer;
    using reference = Reference;
};

// Iterator traits
template<typename Iterator>
struct iterator_traits {
    using difference_type = typename Iterator::difference_type;
    using value_type = typename Iterator::value_type;
    using pointer = typename Iterator::pointer;
    using reference = typename Iterator::reference;
    using iterator_category = typename Iterator::iterator_category;
};

// Pointer specialization
template<typename T>
struct iterator_traits<T*> {
    using difference_type = long;
    using value_type = T;
    using pointer = T*;
    using reference = T&;
    using iterator_category = random_access_iterator_tag;
};

// const pointer specialization
template<typename T>
struct iterator_traits<const T*> {
    using difference_type = long;
    using value_type = T;
    using pointer = const T*;
    using reference = const T&;
    using iterator_category = random_access_iterator_tag;
};

// reverse_iterator adapter
template<typename Iterator>
class reverse_iterator {
public:
    using iterator_type = Iterator;
    using difference_type = typename iterator_traits<Iterator>::difference_type;
    using value_type = typename iterator_traits<Iterator>::value_type;
    using pointer = typename iterator_traits<Iterator>::pointer;
    using reference = typename iterator_traits<Iterator>::reference;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;

    constexpr reverse_iterator() : current_() {}
    constexpr explicit reverse_iterator(Iterator x) : current_(x) {}

    template<typename U>
    constexpr reverse_iterator(const reverse_iterator<U>& other) : current_(other.base()) {}

    template<typename U>
    constexpr reverse_iterator& operator=(const reverse_iterator<U>& other) {
        current_ = other.base();
        return *this;
    }

    constexpr Iterator base() const { return current_; }

    constexpr reference operator*() const {
        Iterator tmp = current_;
        return *--tmp;
    }

    constexpr pointer operator->() const {
        Iterator tmp = current_;
        --tmp;
        return &(*tmp);
    }

    constexpr reference operator[](difference_type n) const {
        return *(*this + n);
    }

    constexpr reverse_iterator& operator++() {
        --current_;
        return *this;
    }

    constexpr reverse_iterator operator++(int) {
        reverse_iterator tmp = *this;
        --current_;
        return tmp;
    }

    constexpr reverse_iterator& operator--() {
        ++current_;
        return *this;
    }

    constexpr reverse_iterator operator--(int) {
        reverse_iterator tmp = *this;
        ++current_;
        return tmp;
    }

    constexpr reverse_iterator operator+(difference_type n) const {
        return reverse_iterator(current_ - n);
    }

    constexpr reverse_iterator& operator+=(difference_type n) {
        current_ -= n;
        return *this;
    }

    constexpr reverse_iterator operator-(difference_type n) const {
        return reverse_iterator(current_ + n);
    }

    constexpr reverse_iterator& operator-=(difference_type n) {
        current_ += n;
        return *this;
    }

protected:
    Iterator current_;
};

// Comparison operators for reverse_iterator
template<typename Iterator1, typename Iterator2>
constexpr bool operator==(const reverse_iterator<Iterator1>& x,
                          const reverse_iterator<Iterator2>& y) {
    return x.base() == y.base();
}

template<typename Iterator1, typename Iterator2>
constexpr bool operator!=(const reverse_iterator<Iterator1>& x,
                          const reverse_iterator<Iterator2>& y) {
    return x.base() != y.base();
}

template<typename Iterator1, typename Iterator2>
constexpr bool operator<(const reverse_iterator<Iterator1>& x,
                         const reverse_iterator<Iterator2>& y) {
    return x.base() > y.base();
}

template<typename Iterator1, typename Iterator2>
constexpr bool operator<=(const reverse_iterator<Iterator1>& x,
                          const reverse_iterator<Iterator2>& y) {
    return x.base() >= y.base();
}

template<typename Iterator1, typename Iterator2>
constexpr bool operator>(const reverse_iterator<Iterator1>& x,
                         const reverse_iterator<Iterator2>& y) {
    return x.base() < y.base();
}

template<typename Iterator1, typename Iterator2>
constexpr bool operator>=(const reverse_iterator<Iterator1>& x,
                          const reverse_iterator<Iterator2>& y) {
    return x.base() <= y.base();
}

template<typename Iterator>
constexpr reverse_iterator<Iterator> operator+(
    typename reverse_iterator<Iterator>::difference_type n,
    const reverse_iterator<Iterator>& x) {
    return reverse_iterator<Iterator>(x.base() - n);
}

template<typename Iterator1, typename Iterator2>
constexpr auto operator-(const reverse_iterator<Iterator1>& x,
                         const reverse_iterator<Iterator2>& y) {
    return y.base() - x.base();
}

// make_reverse_iterator helper
template<typename Iterator>
constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i) {
    return reverse_iterator<Iterator>(i);
}

// move_iterator adapter
template<typename Iterator>
class move_iterator {
public:
    using iterator_type = Iterator;
    using difference_type = typename iterator_traits<Iterator>::difference_type;
    using value_type = typename iterator_traits<Iterator>::value_type;
    using pointer = Iterator;
    using reference = value_type&&;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;

    constexpr move_iterator() : current_() {}
    constexpr explicit move_iterator(Iterator x) : current_(x) {}

    template<typename U>
    constexpr move_iterator(const move_iterator<U>& other) : current_(other.base()) {}

    constexpr Iterator base() const { return current_; }

    constexpr reference operator*() const {
        return static_cast<reference>(*current_);
    }

    constexpr pointer operator->() const { return current_; }

    constexpr reference operator[](difference_type n) const {
        return static_cast<reference>(current_[n]);
    }

    constexpr move_iterator& operator++() {
        ++current_;
        return *this;
    }

    constexpr move_iterator operator++(int) {
        move_iterator tmp = *this;
        ++current_;
        return tmp;
    }

    constexpr move_iterator& operator--() {
        --current_;
        return *this;
    }

    constexpr move_iterator operator--(int) {
        move_iterator tmp = *this;
        --current_;
        return tmp;
    }

    constexpr move_iterator operator+(difference_type n) const {
        return move_iterator(current_ + n);
    }

    constexpr move_iterator& operator+=(difference_type n) {
        current_ += n;
        return *this;
    }

    constexpr move_iterator operator-(difference_type n) const {
        return move_iterator(current_ - n);
    }

    constexpr move_iterator& operator-=(difference_type n) {
        current_ -= n;
        return *this;
    }

private:
    Iterator current_;
};

template<typename Iterator>
constexpr move_iterator<Iterator> make_move_iterator(Iterator i) {
    return move_iterator<Iterator>(i);
}

// Iterator operations
template<typename InputIt>
constexpr typename iterator_traits<InputIt>::difference_type
distance(InputIt first, InputIt last) {
    typename iterator_traits<InputIt>::difference_type result = 0;
    while (first != last) {
        ++first;
        ++result;
    }
    return result;
}

template<typename InputIt, typename Distance>
constexpr void advance(InputIt& it, Distance n) {
    while (n > 0) {
        ++it;
        --n;
    }
    while (n < 0) {
        --it;
        ++n;
    }
}

template<typename InputIt>
constexpr InputIt next(InputIt it, typename iterator_traits<InputIt>::difference_type n = 1) {
    advance(it, n);
    return it;
}

template<typename BidirIt>
constexpr BidirIt prev(BidirIt it, typename iterator_traits<BidirIt>::difference_type n = 1) {
    advance(it, -n);
    return it;
}

// back_insert_iterator
template<typename Container>
class back_insert_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using container_type = Container;

    explicit back_insert_iterator(Container& c) : container_(&c) {}

    back_insert_iterator& operator=(const typename Container::value_type& value) {
        container_->push_back(value);
        return *this;
    }

    back_insert_iterator& operator=(typename Container::value_type&& value) {
        container_->push_back(static_cast<typename Container::value_type&&>(value));
        return *this;
    }

    back_insert_iterator& operator*() { return *this; }
    back_insert_iterator& operator++() { return *this; }
    back_insert_iterator operator++(int) { return *this; }

protected:
    Container* container_;
};

template<typename Container>
back_insert_iterator<Container> back_inserter(Container& c) {
    return back_insert_iterator<Container>(c);
}

// front_insert_iterator
template<typename Container>
class front_insert_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using container_type = Container;

    explicit front_insert_iterator(Container& c) : container_(&c) {}

    front_insert_iterator& operator=(const typename Container::value_type& value) {
        container_->push_front(value);
        return *this;
    }

    front_insert_iterator& operator=(typename Container::value_type&& value) {
        container_->push_front(static_cast<typename Container::value_type&&>(value));
        return *this;
    }

    front_insert_iterator& operator*() { return *this; }
    front_insert_iterator& operator++() { return *this; }
    front_insert_iterator operator++(int) { return *this; }

protected:
    Container* container_;
};

template<typename Container>
front_insert_iterator<Container> front_inserter(Container& c) {
    return front_insert_iterator<Container>(c);
}

// insert_iterator
template<typename Container>
class insert_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using container_type = Container;

    insert_iterator(Container& c, typename Container::iterator i)
        : container_(&c), iter_(i) {}

    insert_iterator& operator=(const typename Container::value_type& value) {
        iter_ = container_->insert(iter_, value);
        ++iter_;
        return *this;
    }

    insert_iterator& operator=(typename Container::value_type&& value) {
        iter_ = container_->insert(iter_, static_cast<typename Container::value_type&&>(value));
        ++iter_;
        return *this;
    }

    insert_iterator& operator*() { return *this; }
    insert_iterator& operator++() { return *this; }
    insert_iterator& operator++(int) { return *this; }

protected:
    Container* container_;
    typename Container::iterator iter_;
};

template<typename Container>
insert_iterator<Container> inserter(Container& c, typename Container::iterator i) {
    return insert_iterator<Container>(c, i);
}

// Range access functions
template<typename C>
constexpr auto begin(C& c) -> decltype(c.begin()) { return c.begin(); }

template<typename C>
constexpr auto begin(const C& c) -> decltype(c.begin()) { return c.begin(); }

template<typename C>
constexpr auto end(C& c) -> decltype(c.end()) { return c.end(); }

template<typename C>
constexpr auto end(const C& c) -> decltype(c.end()) { return c.end(); }

template<typename T, size_t N>
constexpr T* begin(T (&array)[N]) noexcept { return array; }

template<typename T, size_t N>
constexpr T* end(T (&array)[N]) noexcept { return array + N; }

template<typename C>
constexpr auto cbegin(const C& c) noexcept -> decltype(begin(c)) { return begin(c); }

template<typename C>
constexpr auto cend(const C& c) noexcept -> decltype(end(c)) { return end(c); }

template<typename C>
constexpr auto rbegin(C& c) -> decltype(c.rbegin()) { return c.rbegin(); }

template<typename C>
constexpr auto rbegin(const C& c) -> decltype(c.rbegin()) { return c.rbegin(); }

template<typename C>
constexpr auto rend(C& c) -> decltype(c.rend()) { return c.rend(); }

template<typename C>
constexpr auto rend(const C& c) -> decltype(c.rend()) { return c.rend(); }

template<typename T, size_t N>
constexpr reverse_iterator<T*> rbegin(T (&array)[N]) {
    return reverse_iterator<T*>(array + N);
}

template<typename T, size_t N>
constexpr reverse_iterator<T*> rend(T (&array)[N]) {
    return reverse_iterator<T*>(array);
}

template<typename C>
constexpr auto crbegin(const C& c) -> decltype(rbegin(c)) { return rbegin(c); }

template<typename C>
constexpr auto crend(const C& c) -> decltype(rend(c)) { return rend(c); }

// size, empty, data
template<typename C>
constexpr auto size(const C& c) -> decltype(c.size()) { return c.size(); }

template<typename T, size_t N>
constexpr size_t size(const T (&array)[N]) noexcept { return N; }

template<typename C>
constexpr auto ssize(const C& c) -> long { return static_cast<long>(c.size()); }

template<typename T, size_t N>
constexpr long ssize(const T (&array)[N]) noexcept { return static_cast<long>(N); }

template<typename C>
[[nodiscard]] constexpr auto empty(const C& c) -> decltype(c.empty()) { return c.empty(); }

template<typename T, size_t N>
[[nodiscard]] constexpr bool empty(const T (&array)[N]) noexcept { return false; }

template<typename C>
constexpr auto data(C& c) -> decltype(c.data()) { return c.data(); }

template<typename C>
constexpr auto data(const C& c) -> decltype(c.data()) { return c.data(); }

template<typename T, size_t N>
constexpr T* data(T (&array)[N]) noexcept { return array; }

} // namespace std

#endif // _FRAGILE_ITERATOR_
