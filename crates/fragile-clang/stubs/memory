// Minimal memory stub for fragile parsing
#ifndef _FRAGILE_MEMORY_
#define _FRAGILE_MEMORY_

#include "cstdint"
#include "cstddef"
#include "utility"
#include "tuple"
#include "new"  // For placement new operator

namespace std {

// allocator_arg_t - tag type for uses-allocator construction
struct allocator_arg_t { explicit allocator_arg_t() = default; };
inline constexpr allocator_arg_t allocator_arg{};

// Forward declarations
template<typename T> class shared_ptr;
template<typename T> class weak_ptr;
template<typename T> class unique_ptr;
template<typename T> class allocator;

// allocator
template<typename T>
class allocator {
public:
    using value_type = T;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal = true_type;

    template<typename U>
    struct rebind { using other = allocator<U>; };

    constexpr allocator() noexcept = default;
    constexpr allocator(const allocator&) noexcept = default;
    template<typename U>
    constexpr allocator(const allocator<U>&) noexcept {}

    ~allocator() = default;

    [[nodiscard]] T* allocate(size_t n) {
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, size_t n) noexcept {
        ::operator delete(p);
    }

    size_type max_size() const noexcept {
        return static_cast<size_type>(-1) / sizeof(T);
    }

    template<typename U, typename... Args>
    void construct(U* p, Args&&... args) {
        ::new(static_cast<void*>(p)) U(static_cast<Args&&>(args)...);
    }

    template<typename U>
    void destroy(U* p) {
        p->~U();
    }

    pointer address(reference x) const noexcept { return &x; }
    const_pointer address(const_reference x) const noexcept { return &x; }
};

template<typename T, typename U>
bool operator==(const allocator<T>&, const allocator<U>&) noexcept { return true; }

template<typename T, typename U>
bool operator!=(const allocator<T>&, const allocator<U>&) noexcept { return false; }

// allocator_traits
template<typename Alloc>
struct allocator_traits {
    using allocator_type = Alloc;
    using value_type = typename Alloc::value_type;
    using pointer = typename Alloc::pointer;
    using const_pointer = typename Alloc::const_pointer;
    using size_type = typename Alloc::size_type;
    using difference_type = typename Alloc::difference_type;

    [[nodiscard]] static pointer allocate(Alloc& a, size_type n) {
        return a.allocate(n);
    }

    static void deallocate(Alloc& a, pointer p, size_type n) {
        a.deallocate(p, n);
    }

    template<typename T, typename... Args>
    static void construct(Alloc& a, T* p, Args&&... args) {
        ::new(static_cast<void*>(p)) T(static_cast<Args&&>(args)...);
    }

    template<typename T>
    static void destroy(Alloc& a, T* p) {
        p->~T();
    }

    static size_type max_size(const Alloc& a) noexcept {
        return a.max_size();
    }
};

// shared_ptr
template<typename T>
class shared_ptr {
public:
    using element_type = T;

    constexpr shared_ptr() noexcept : ptr_(nullptr) {}
    constexpr shared_ptr(nullptr_t) noexcept : ptr_(nullptr) {}

    template<typename U>
    explicit shared_ptr(U* p) : ptr_(p) {}

    shared_ptr(const shared_ptr& other) noexcept : ptr_(other.ptr_) {}

    template<typename U>
    shared_ptr(const shared_ptr<U>& other) noexcept : ptr_(other.get()) {}

    shared_ptr(shared_ptr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    template<typename U>
    shared_ptr(shared_ptr<U>&& other) noexcept : ptr_(other.get()) {
        other.reset();
    }

    ~shared_ptr() = default;

    shared_ptr& operator=(const shared_ptr& other) noexcept {
        ptr_ = other.ptr_;
        return *this;
    }

    template<typename U>
    shared_ptr& operator=(const shared_ptr<U>& other) noexcept {
        ptr_ = other.get();
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& other) noexcept {
        ptr_ = other.ptr_;
        other.ptr_ = nullptr;
        return *this;
    }

    template<typename U>
    shared_ptr& operator=(shared_ptr<U>&& other) noexcept {
        ptr_ = other.get();
        other.reset();
        return *this;
    }

    void reset() noexcept { ptr_ = nullptr; }

    template<typename U>
    void reset(U* p) { ptr_ = p; }

    T* get() const noexcept { return ptr_; }
    T& operator*() const noexcept { return *ptr_; }
    T* operator->() const noexcept { return ptr_; }

    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    long use_count() const noexcept { return ptr_ ? 1 : 0; }

    bool operator==(const shared_ptr& other) const noexcept { return ptr_ == other.ptr_; }
    bool operator!=(const shared_ptr& other) const noexcept { return ptr_ != other.ptr_; }
    bool operator==(nullptr_t) const noexcept { return ptr_ == nullptr; }
    bool operator!=(nullptr_t) const noexcept { return ptr_ != nullptr; }

private:
    T* ptr_;
};

// make_shared
template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args) {
    return shared_ptr<T>(new T(static_cast<Args&&>(args)...));
}

// weak_ptr
template<typename T>
class weak_ptr {
public:
    constexpr weak_ptr() noexcept : ptr_(nullptr) {}

    weak_ptr(const weak_ptr& other) noexcept : ptr_(other.ptr_) {}

    template<typename U>
    weak_ptr(const shared_ptr<U>& other) noexcept : ptr_(other.get()) {}

    ~weak_ptr() = default;

    weak_ptr& operator=(const weak_ptr& other) noexcept {
        ptr_ = other.ptr_;
        return *this;
    }

    template<typename U>
    weak_ptr& operator=(const shared_ptr<U>& other) noexcept {
        ptr_ = other.get();
        return *this;
    }

    void reset() noexcept { ptr_ = nullptr; }
    bool expired() const noexcept { return ptr_ == nullptr; }
    shared_ptr<T> lock() const noexcept { return shared_ptr<T>(ptr_); }

private:
    T* ptr_;
};

// unique_ptr
template<typename T>
class unique_ptr {
public:
    using element_type = T;
    using pointer = T*;

    constexpr unique_ptr() noexcept : ptr_(nullptr) {}
    constexpr unique_ptr(nullptr_t) noexcept : ptr_(nullptr) {}
    explicit unique_ptr(pointer p) noexcept : ptr_(p) {}

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    unique_ptr(unique_ptr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            delete ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }

    unique_ptr& operator=(nullptr_t) noexcept {
        delete ptr_;
        ptr_ = nullptr;
        return *this;
    }

    ~unique_ptr() { delete ptr_; }

    pointer release() noexcept {
        pointer p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    void reset(pointer p = pointer()) noexcept {
        delete ptr_;
        ptr_ = p;
    }

    pointer get() const noexcept { return ptr_; }
    T& operator*() const { return *ptr_; }
    pointer operator->() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

private:
    pointer ptr_;
};

// make_unique
template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args) {
    return unique_ptr<T>(new T(static_cast<Args&&>(args)...));
}

// static_pointer_cast
template<typename T, typename U>
shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept {
    return shared_ptr<T>(static_cast<T*>(r.get()));
}

// dynamic_pointer_cast
template<typename T, typename U>
shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept {
    if (T* p = dynamic_cast<T*>(r.get())) {
        return shared_ptr<T>(p);
    }
    return shared_ptr<T>();
}

// const_pointer_cast
template<typename T, typename U>
shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept {
    return shared_ptr<T>(const_cast<T*>(r.get()));
}

// addressof
template<typename T>
T* addressof(T& arg) noexcept {
    return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char&>(arg)));
}

// enable_shared_from_this - base class for objects that want to create shared_ptr to themselves
template<typename T>
class enable_shared_from_this {
protected:
    constexpr enable_shared_from_this() noexcept = default;
    enable_shared_from_this(const enable_shared_from_this&) noexcept = default;
    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { return *this; }
    ~enable_shared_from_this() = default;

public:
    shared_ptr<T> shared_from_this() {
        return shared_ptr<T>(static_cast<T*>(this));
    }
    shared_ptr<const T> shared_from_this() const {
        return shared_ptr<const T>(static_cast<const T*>(this));
    }
    weak_ptr<T> weak_from_this() noexcept {
        return weak_ptr<T>(shared_from_this());
    }
    weak_ptr<const T> weak_from_this() const noexcept {
        return weak_ptr<const T>(shared_from_this());
    }
};

} // namespace std

#endif // _FRAGILE_MEMORY_
