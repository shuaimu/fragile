// Minimal memory stub for fragile parsing
#ifndef _FRAGILE_MEMORY_
#define _FRAGILE_MEMORY_

#include "cstdint"
#include "utility"
#include "tuple"
#include "new"  // For placement new operator

namespace std {

// Forward declarations
template<typename T> class shared_ptr;
template<typename T> class weak_ptr;
template<typename T> class unique_ptr;

// shared_ptr
template<typename T>
class shared_ptr {
public:
    using element_type = T;

    constexpr shared_ptr() noexcept : ptr_(nullptr) {}
    constexpr shared_ptr(nullptr_t) noexcept : ptr_(nullptr) {}

    template<typename U>
    explicit shared_ptr(U* p) : ptr_(p) {}

    shared_ptr(const shared_ptr& other) noexcept : ptr_(other.ptr_) {}

    template<typename U>
    shared_ptr(const shared_ptr<U>& other) noexcept : ptr_(other.get()) {}

    shared_ptr(shared_ptr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    template<typename U>
    shared_ptr(shared_ptr<U>&& other) noexcept : ptr_(other.get()) {
        other.reset();
    }

    ~shared_ptr() = default;

    shared_ptr& operator=(const shared_ptr& other) noexcept {
        ptr_ = other.ptr_;
        return *this;
    }

    template<typename U>
    shared_ptr& operator=(const shared_ptr<U>& other) noexcept {
        ptr_ = other.get();
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& other) noexcept {
        ptr_ = other.ptr_;
        other.ptr_ = nullptr;
        return *this;
    }

    template<typename U>
    shared_ptr& operator=(shared_ptr<U>&& other) noexcept {
        ptr_ = other.get();
        other.reset();
        return *this;
    }

    void reset() noexcept { ptr_ = nullptr; }

    template<typename U>
    void reset(U* p) { ptr_ = p; }

    T* get() const noexcept { return ptr_; }
    T& operator*() const noexcept { return *ptr_; }
    T* operator->() const noexcept { return ptr_; }

    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    long use_count() const noexcept { return ptr_ ? 1 : 0; }

    bool operator==(const shared_ptr& other) const noexcept { return ptr_ == other.ptr_; }
    bool operator!=(const shared_ptr& other) const noexcept { return ptr_ != other.ptr_; }
    bool operator==(nullptr_t) const noexcept { return ptr_ == nullptr; }
    bool operator!=(nullptr_t) const noexcept { return ptr_ != nullptr; }

private:
    T* ptr_;
};

// make_shared
template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args) {
    return shared_ptr<T>(new T(static_cast<Args&&>(args)...));
}

// weak_ptr
template<typename T>
class weak_ptr {
public:
    constexpr weak_ptr() noexcept : ptr_(nullptr) {}

    weak_ptr(const weak_ptr& other) noexcept : ptr_(other.ptr_) {}

    template<typename U>
    weak_ptr(const shared_ptr<U>& other) noexcept : ptr_(other.get()) {}

    ~weak_ptr() = default;

    weak_ptr& operator=(const weak_ptr& other) noexcept {
        ptr_ = other.ptr_;
        return *this;
    }

    template<typename U>
    weak_ptr& operator=(const shared_ptr<U>& other) noexcept {
        ptr_ = other.get();
        return *this;
    }

    void reset() noexcept { ptr_ = nullptr; }
    bool expired() const noexcept { return ptr_ == nullptr; }
    shared_ptr<T> lock() const noexcept { return shared_ptr<T>(ptr_); }

private:
    T* ptr_;
};

// unique_ptr
template<typename T>
class unique_ptr {
public:
    using element_type = T;
    using pointer = T*;

    constexpr unique_ptr() noexcept : ptr_(nullptr) {}
    constexpr unique_ptr(nullptr_t) noexcept : ptr_(nullptr) {}
    explicit unique_ptr(pointer p) noexcept : ptr_(p) {}

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    unique_ptr(unique_ptr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            delete ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }

    unique_ptr& operator=(nullptr_t) noexcept {
        delete ptr_;
        ptr_ = nullptr;
        return *this;
    }

    ~unique_ptr() { delete ptr_; }

    pointer release() noexcept {
        pointer p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    void reset(pointer p = pointer()) noexcept {
        delete ptr_;
        ptr_ = p;
    }

    pointer get() const noexcept { return ptr_; }
    T& operator*() const { return *ptr_; }
    pointer operator->() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

private:
    pointer ptr_;
};

// make_unique
template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args) {
    return unique_ptr<T>(new T(static_cast<Args&&>(args)...));
}

// addressof
template<typename T>
T* addressof(T& arg) noexcept {
    return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char&>(arg)));
}

} // namespace std

#endif // _FRAGILE_MEMORY_
