// Minimal cstddef stub for fragile parsing
#ifndef _FRAGILE_CSTDDEF_
#define _FRAGILE_CSTDDEF_

#include "cstdint"
#include "cstdlib"
#include "new"  // For placement new

namespace std {

// size_t is already in cstdint
using ::size_t;

// ptrdiff_t
using ptrdiff_t = long;

// nullptr_t is already in cstdint
using ::nullptr_t;

// max_align_t - if clang's header defined ::max_align_t, bring it to std::
// Otherwise define it ourselves
#ifdef __CLANG_MAX_ALIGN_T_DEFINED
using max_align_t = ::max_align_t;
#else
#define __CLANG_MAX_ALIGN_T_DEFINED
struct max_align_t {
    long long __clang_max_align_nonce1;
    long double __clang_max_align_nonce2;
};
#endif

// byte (C++17)
enum class byte : unsigned char {};

// byte operations
template<typename IntType>
constexpr byte& operator<<=(byte& b, IntType shift) noexcept {
    return b = byte(static_cast<unsigned char>(b) << shift);
}

template<typename IntType>
constexpr byte operator<<(byte b, IntType shift) noexcept {
    return byte(static_cast<unsigned char>(b) << shift);
}

template<typename IntType>
constexpr byte& operator>>=(byte& b, IntType shift) noexcept {
    return b = byte(static_cast<unsigned char>(b) >> shift);
}

template<typename IntType>
constexpr byte operator>>(byte b, IntType shift) noexcept {
    return byte(static_cast<unsigned char>(b) >> shift);
}

constexpr byte& operator|=(byte& l, byte r) noexcept {
    return l = byte(static_cast<unsigned char>(l) | static_cast<unsigned char>(r));
}

constexpr byte operator|(byte l, byte r) noexcept {
    return byte(static_cast<unsigned char>(l) | static_cast<unsigned char>(r));
}

constexpr byte& operator&=(byte& l, byte r) noexcept {
    return l = byte(static_cast<unsigned char>(l) & static_cast<unsigned char>(r));
}

constexpr byte operator&(byte l, byte r) noexcept {
    return byte(static_cast<unsigned char>(l) & static_cast<unsigned char>(r));
}

constexpr byte& operator^=(byte& l, byte r) noexcept {
    return l = byte(static_cast<unsigned char>(l) ^ static_cast<unsigned char>(r));
}

constexpr byte operator^(byte l, byte r) noexcept {
    return byte(static_cast<unsigned char>(l) ^ static_cast<unsigned char>(r));
}

constexpr byte operator~(byte b) noexcept {
    return byte(~static_cast<unsigned char>(b));
}

template<typename IntType>
constexpr IntType to_integer(byte b) noexcept {
    return static_cast<IntType>(b);
}

} // namespace std

// C-style global definitions
using std::ptrdiff_t;
using std::max_align_t;

// offsetof macro
#define offsetof(type, member) __builtin_offsetof(type, member)

// NULL macro
#ifndef NULL
#define NULL nullptr
#endif

#endif // _FRAGILE_CSTDDEF_
