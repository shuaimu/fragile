// Minimal type_traits stub for fragile parsing
#ifndef _FRAGILE_TYPE_TRAITS_
#define _FRAGILE_TYPE_TRAITS_

#include "cstdint"

namespace std {

// integral_constant
template<typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

// Primary type categories
template<typename T> struct is_void : false_type {};
template<> struct is_void<void> : true_type {};

template<typename T> struct is_null_pointer : false_type {};
template<> struct is_null_pointer<decltype(nullptr)> : true_type {};

template<typename T> struct is_integral : false_type {};
template<> struct is_integral<bool> : true_type {};
template<> struct is_integral<char> : true_type {};
template<> struct is_integral<signed char> : true_type {};
template<> struct is_integral<unsigned char> : true_type {};
template<> struct is_integral<short> : true_type {};
template<> struct is_integral<unsigned short> : true_type {};
template<> struct is_integral<int> : true_type {};
template<> struct is_integral<unsigned int> : true_type {};
template<> struct is_integral<long> : true_type {};
template<> struct is_integral<unsigned long> : true_type {};
template<> struct is_integral<long long> : true_type {};
template<> struct is_integral<unsigned long long> : true_type {};

template<typename T> struct is_floating_point : false_type {};
template<> struct is_floating_point<float> : true_type {};
template<> struct is_floating_point<double> : true_type {};
template<> struct is_floating_point<long double> : true_type {};

template<typename T> struct is_array : false_type {};
template<typename T> struct is_array<T[]> : true_type {};
template<typename T, size_t N> struct is_array<T[N]> : true_type {};

template<typename T> struct is_pointer : false_type {};
template<typename T> struct is_pointer<T*> : true_type {};

template<typename T> struct is_lvalue_reference : false_type {};
template<typename T> struct is_lvalue_reference<T&> : true_type {};

template<typename T> struct is_rvalue_reference : false_type {};
template<typename T> struct is_rvalue_reference<T&&> : true_type {};

template<typename T> struct is_reference : false_type {};
template<typename T> struct is_reference<T&> : true_type {};
template<typename T> struct is_reference<T&&> : true_type {};

template<typename T> struct is_function : false_type {};

template<typename T> struct is_const : false_type {};
template<typename T> struct is_const<const T> : true_type {};

template<typename T> struct is_volatile : false_type {};
template<typename T> struct is_volatile<volatile T> : true_type {};

// Composite type categories
template<typename T>
struct is_arithmetic : integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

template<typename T>
struct is_fundamental : integral_constant<bool, is_arithmetic<T>::value || is_void<T>::value || is_null_pointer<T>::value> {};

template<typename T>
struct is_object : integral_constant<bool, !is_function<T>::value && !is_reference<T>::value && !is_void<T>::value> {};

template<typename T>
struct is_scalar : integral_constant<bool, is_arithmetic<T>::value || is_pointer<T>::value || is_null_pointer<T>::value> {};

template<typename T>
struct is_compound : integral_constant<bool, !is_fundamental<T>::value> {};

// Type properties
template<typename T> struct is_trivially_copyable : true_type {};
template<typename T> struct is_trivially_destructible : true_type {};
template<typename T> struct is_trivially_constructible : true_type {};
template<typename T> struct is_trivially_default_constructible : true_type {};
template<typename T> struct is_trivially_copy_constructible : true_type {};
template<typename T> struct is_trivially_move_constructible : true_type {};
template<typename T> struct is_trivially_copy_assignable : true_type {};
template<typename T> struct is_trivially_move_assignable : true_type {};

template<typename T> struct is_standard_layout : true_type {};
template<typename T> struct is_empty : false_type {};
template<typename T> struct is_polymorphic : false_type {};
template<typename T> struct is_abstract : false_type {};
template<typename T> struct is_final : false_type {};

template<typename T> struct is_signed : integral_constant<bool, T(-1) < T(0)> {};
template<typename T> struct is_unsigned : integral_constant<bool, T(0) < T(-1)> {};

// Type relationships
template<typename T, typename U> struct is_same : false_type {};
template<typename T> struct is_same<T, T> : true_type {};

template<typename Base, typename Derived>
struct is_base_of : integral_constant<bool, __is_base_of(Base, Derived)> {};

template<typename From, typename To>
struct is_convertible : integral_constant<bool, __is_convertible_to(From, To)> {};

// Const-volatility specifiers
template<typename T> struct remove_const { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };

template<typename T> struct remove_volatile { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };

template<typename T> struct remove_cv { using type = T; };
template<typename T> struct remove_cv<const T> { using type = T; };
template<typename T> struct remove_cv<volatile T> { using type = T; };
template<typename T> struct remove_cv<const volatile T> { using type = T; };

template<typename T> struct add_const { using type = const T; };
template<typename T> struct add_volatile { using type = volatile T; };
template<typename T> struct add_cv { using type = const volatile T; };

template<typename T> using remove_const_t = typename remove_const<T>::type;
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;
template<typename T> using remove_cv_t = typename remove_cv<T>::type;
template<typename T> using add_const_t = typename add_const<T>::type;
template<typename T> using add_volatile_t = typename add_volatile<T>::type;
template<typename T> using add_cv_t = typename add_cv<T>::type;

// References
template<typename T> struct remove_reference { using type = T; };
template<typename T> struct remove_reference<T&> { using type = T; };
template<typename T> struct remove_reference<T&&> { using type = T; };

template<typename T> struct add_lvalue_reference { using type = T&; };
template<typename T> struct add_rvalue_reference { using type = T&&; };

template<typename T> using remove_reference_t = typename remove_reference<T>::type;
template<typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
template<typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// declval (must be before common_type which uses it)
template<typename T>
add_rvalue_reference_t<T> declval() noexcept;

// Pointers
template<typename T> struct remove_pointer { using type = T; };
template<typename T> struct remove_pointer<T*> { using type = T; };
template<typename T> struct remove_pointer<T* const> { using type = T; };
template<typename T> struct remove_pointer<T* volatile> { using type = T; };
template<typename T> struct remove_pointer<T* const volatile> { using type = T; };

template<typename T> struct add_pointer { using type = T*; };

template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

// Arrays
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, size_t N> struct remove_extent<T[N]> { using type = T; };

template<typename T> struct remove_all_extents { using type = T; };
template<typename T> struct remove_all_extents<T[]> { using type = typename remove_all_extents<T>::type; };
template<typename T, size_t N> struct remove_all_extents<T[N]> { using type = typename remove_all_extents<T>::type; };

template<typename T> using remove_extent_t = typename remove_extent<T>::type;
template<typename T> using remove_all_extents_t = typename remove_all_extents<T>::type;

// Other transformations
template<typename T>
struct decay {
private:
    using U = remove_reference_t<T>;
public:
    using type = typename remove_cv<U>::type;
};

template<typename T> using decay_t = typename decay<T>::type;

template<bool B, typename T = void> struct enable_if {};
template<typename T> struct enable_if<true, T> { using type = T; };
template<bool B, typename T = void> using enable_if_t = typename enable_if<B, T>::type;

template<bool B, typename T, typename F> struct conditional { using type = T; };
template<typename T, typename F> struct conditional<false, T, F> { using type = F; };
template<bool B, typename T, typename F> using conditional_t = typename conditional<B, T, F>::type;

template<typename... T> struct common_type;
template<typename T> struct common_type<T> { using type = decay_t<T>; };
template<typename T, typename U>
struct common_type<T, U> {
    using type = decay_t<decltype(true ? declval<T>() : declval<U>())>;
};
template<typename T, typename U, typename... V>
struct common_type<T, U, V...> {
    using type = typename common_type<typename common_type<T, U>::type, V...>::type;
};
template<typename... T> using common_type_t = typename common_type<T...>::type;

// void_t
template<typename...>
using void_t = void;

// Variable templates (C++17)
template<typename T> inline constexpr bool is_void_v = is_void<T>::value;
template<typename T> inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
template<typename T> inline constexpr bool is_integral_v = is_integral<T>::value;
template<typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
template<typename T> inline constexpr bool is_array_v = is_array<T>::value;
template<typename T> inline constexpr bool is_pointer_v = is_pointer<T>::value;
template<typename T> inline constexpr bool is_reference_v = is_reference<T>::value;
template<typename T> inline constexpr bool is_const_v = is_const<T>::value;
template<typename T> inline constexpr bool is_volatile_v = is_volatile<T>::value;
template<typename T, typename U> inline constexpr bool is_same_v = is_same<T, U>::value;
template<typename Base, typename Derived> inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;
template<typename T> inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;

// aligned_storage (deprecated in C++23 but needed for rusty-cpp)
template<size_t Len, size_t Align = alignof(long double)>
struct aligned_storage {
    struct type {
        alignas(Align) unsigned char data[Len];
    };
};

template<size_t Len, size_t Align = alignof(long double)>
using aligned_storage_t = typename aligned_storage<Len, Align>::type;

// aligned_union (deprecated in C++23)
template<size_t Len, typename... Types>
struct aligned_union {
    static constexpr size_t alignment_value = 1;
    struct type {
        alignas(alignment_value) unsigned char data[Len];
    };
};

} // namespace std

#endif // _FRAGILE_TYPE_TRAITS_
