// Minimal filesystem stub for fragile parsing
#ifndef _FRAGILE_FILESYSTEM_
#define _FRAGILE_FILESYSTEM_

#include "string"
#include "cstdint"
#include "chrono"

namespace std {
namespace filesystem {

// Basic path class
class path {
public:
    using value_type = char;
    using string_type = std::basic_string<value_type>;

    path() = default;
    path(const path&) = default;
    path(path&&) = default;
    path(const string_type& s) : path_(s) {}
    path(const char* s) : path_(s) {}

    template<typename Source>
    path(const Source& source) : path_(source) {}

    path& operator=(const path&) = default;
    path& operator=(path&&) = default;

    // Concatenation
    path& operator/=(const path& p) {
        if (!path_.empty() && path_.back() != '/') path_ += '/';
        path_ += p.path_;
        return *this;
    }

    path operator/(const path& p) const {
        path result = *this;
        result /= p;
        return result;
    }

    // Observers
    const string_type& native() const noexcept { return path_; }
    const value_type* c_str() const noexcept { return path_.c_str(); }
    operator string_type() const { return path_; }
    string_type string() const { return path_; }

    // Decomposition
    path root_name() const { return path(); }
    path root_directory() const { return path(); }
    path root_path() const { return path(); }
    path relative_path() const { return path_; }
    path parent_path() const {
        auto pos = path_.rfind('/');
        if (pos == string_type::npos) return path();
        return path_.substr(0, pos);
    }
    path filename() const {
        auto pos = path_.rfind('/');
        if (pos == string_type::npos) return path_;
        return path_.substr(pos + 1);
    }
    path stem() const {
        auto fn = filename().string();
        auto pos = fn.rfind('.');
        if (pos == string_type::npos || pos == 0) return fn;
        return fn.substr(0, pos);
    }
    path extension() const {
        auto fn = filename().string();
        auto pos = fn.rfind('.');
        if (pos == string_type::npos || pos == 0) return path();
        return fn.substr(pos);
    }

    // Queries
    bool empty() const noexcept { return path_.empty(); }
    bool has_root_name() const { return false; }
    bool has_root_directory() const { return !path_.empty() && path_[0] == '/'; }
    bool has_root_path() const { return has_root_directory(); }
    bool has_relative_path() const { return !relative_path().empty(); }
    bool has_parent_path() const { return !parent_path().empty(); }
    bool has_filename() const { return !filename().empty(); }
    bool has_stem() const { return !stem().empty(); }
    bool has_extension() const { return !extension().empty(); }
    bool is_absolute() const { return has_root_directory(); }
    bool is_relative() const { return !is_absolute(); }

    // Comparison
    int compare(const path& p) const noexcept { return path_.compare(p.path_); }

    bool operator==(const path& rhs) const { return path_ == rhs.path_; }
    bool operator!=(const path& rhs) const { return path_ != rhs.path_; }
    bool operator<(const path& rhs) const { return path_ < rhs.path_; }
    bool operator<=(const path& rhs) const { return path_ <= rhs.path_; }
    bool operator>(const path& rhs) const { return path_ > rhs.path_; }
    bool operator>=(const path& rhs) const { return path_ >= rhs.path_; }

private:
    string_type path_;
};

// Non-member path operators
inline path operator/(const path& lhs, const path& rhs) {
    return path(lhs) /= rhs;
}

// File status
enum class file_type {
    none = 0,
    not_found = -1,
    regular = 1,
    directory = 2,
    symlink = 3,
    block = 4,
    character = 5,
    fifo = 6,
    socket = 7,
    unknown = 8
};

enum class perms {
    none = 0,
    owner_read = 0400,
    owner_write = 0200,
    owner_exec = 0100,
    owner_all = 0700,
    group_read = 040,
    group_write = 020,
    group_exec = 010,
    group_all = 070,
    others_read = 04,
    others_write = 02,
    others_exec = 01,
    others_all = 07,
    all = 0777,
    set_uid = 04000,
    set_gid = 02000,
    sticky_bit = 01000,
    mask = 07777,
    unknown = 0xFFFF
};

class file_status {
public:
    file_status() noexcept : type_(file_type::none), perms_(perms::unknown) {}
    explicit file_status(file_type t, perms p = perms::unknown) noexcept : type_(t), perms_(p) {}

    file_type type() const noexcept { return type_; }
    perms permissions() const noexcept { return perms_; }

    void type(file_type t) noexcept { type_ = t; }
    void permissions(perms p) noexcept { perms_ = p; }

private:
    file_type type_;
    perms perms_;
};

// Directory entry
class directory_entry {
public:
    directory_entry() = default;
    explicit directory_entry(const path& p) : path_(p) {}

    const path& path() const noexcept { return path_; }
    operator const filesystem::path&() const noexcept { return path_; }

    bool exists() const { return true; }
    bool is_regular_file() const { return true; }
    bool is_directory() const { return false; }

private:
    filesystem::path path_;
};

// Directory iterator
class directory_iterator {
public:
    using value_type = directory_entry;
    using difference_type = long;
    using pointer = const directory_entry*;
    using reference = const directory_entry&;

    directory_iterator() = default;
    explicit directory_iterator(const path& p) {}

    const directory_entry& operator*() const { return entry_; }
    const directory_entry* operator->() const { return &entry_; }
    directory_iterator& operator++() { return *this; }

    bool operator==(const directory_iterator& rhs) const { return false; }
    bool operator!=(const directory_iterator& rhs) const { return false; }

private:
    directory_entry entry_;
};

inline directory_iterator begin(directory_iterator iter) noexcept { return iter; }
inline directory_iterator end(const directory_iterator&) noexcept { return directory_iterator(); }

// Filesystem operations
inline bool exists(const path& p) { return false; }
inline bool is_directory(const path& p) { return false; }
inline bool is_regular_file(const path& p) { return false; }
inline bool is_symlink(const path& p) { return false; }
inline bool is_empty(const path& p) { return true; }

inline bool create_directory(const path& p) { return true; }
inline bool create_directories(const path& p) { return true; }
inline bool remove(const path& p) { return true; }
inline unsigned long remove_all(const path& p) { return 0; }
inline void copy(const path& from, const path& to) {}
inline void rename(const path& old_p, const path& new_p) {}
inline path current_path() { return path(); }
inline void current_path(const path& p) {}
inline path absolute(const path& p) { return p; }
inline path canonical(const path& p) { return p; }
inline unsigned long long file_size(const path& p) { return 0; }

} // namespace filesystem
} // namespace std

#endif // _FRAGILE_FILESYSTEM_
