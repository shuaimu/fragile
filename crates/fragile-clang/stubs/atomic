// Minimal atomic stub for fragile parsing
#ifndef _FRAGILE_ATOMIC_
#define _FRAGILE_ATOMIC_

#include "cstdint"

namespace std {

// Memory order enum
enum class memory_order : int {
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst
};

// Memory order constants
inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
inline constexpr memory_order memory_order_consume = memory_order::consume;
inline constexpr memory_order memory_order_acquire = memory_order::acquire;
inline constexpr memory_order memory_order_release = memory_order::release;
inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;

// Primary atomic template
template<typename T>
struct atomic {
    using value_type = T;

    atomic() noexcept = default;
    constexpr atomic(T desired) noexcept : value_(desired) {}
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;

    // Store operations
    void store(T desired, memory_order order = memory_order_seq_cst) noexcept {
        value_ = desired;
    }

    // Load operations
    T load(memory_order order = memory_order_seq_cst) const noexcept {
        return value_;
    }

    // Exchange operations
    T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = desired;
        return old;
    }

    // Compare-exchange operations
    bool compare_exchange_weak(T& expected, T desired,
                               memory_order success = memory_order_seq_cst,
                               memory_order failure = memory_order_seq_cst) noexcept {
        if (value_ == expected) {
            value_ = desired;
            return true;
        }
        expected = value_;
        return false;
    }

    bool compare_exchange_strong(T& expected, T desired,
                                 memory_order success = memory_order_seq_cst,
                                 memory_order failure = memory_order_seq_cst) noexcept {
        return compare_exchange_weak(expected, desired, success, failure);
    }

    // Operators
    operator T() const noexcept { return load(); }
    T operator=(T desired) noexcept { store(desired); return desired; }

    // Fetch-and-modify operations (for integral types)
    T fetch_add(T arg, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = value_ + arg;
        return old;
    }

    T fetch_sub(T arg, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = value_ - arg;
        return old;
    }

    T fetch_and(T arg, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = value_ & arg;
        return old;
    }

    T fetch_or(T arg, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = value_ | arg;
        return old;
    }

    T fetch_xor(T arg, memory_order order = memory_order_seq_cst) noexcept {
        T old = value_;
        value_ = value_ ^ arg;
        return old;
    }

    // Increment/decrement
    T operator++() noexcept { return fetch_add(T(1)) + T(1); }
    T operator++(int) noexcept { return fetch_add(T(1)); }
    T operator--() noexcept { return fetch_sub(T(1)) - T(1); }
    T operator--(int) noexcept { return fetch_sub(T(1)); }

    T operator+=(T arg) noexcept { return fetch_add(arg) + arg; }
    T operator-=(T arg) noexcept { return fetch_sub(arg) - arg; }
    T operator&=(T arg) noexcept { return fetch_and(arg) & arg; }
    T operator|=(T arg) noexcept { return fetch_or(arg) | arg; }
    T operator^=(T arg) noexcept { return fetch_xor(arg) ^ arg; }

    // Check if lock-free
    bool is_lock_free() const noexcept { return true; }

private:
    T value_;
};

// Specialization for pointers
template<typename T>
struct atomic<T*> {
    using value_type = T*;

    atomic() noexcept = default;
    constexpr atomic(T* desired) noexcept : value_(desired) {}
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;

    void store(T* desired, memory_order order = memory_order_seq_cst) noexcept {
        value_ = desired;
    }

    T* load(memory_order order = memory_order_seq_cst) const noexcept {
        return value_;
    }

    T* exchange(T* desired, memory_order order = memory_order_seq_cst) noexcept {
        T* old = value_;
        value_ = desired;
        return old;
    }

    bool compare_exchange_weak(T*& expected, T* desired,
                               memory_order success = memory_order_seq_cst,
                               memory_order failure = memory_order_seq_cst) noexcept {
        if (value_ == expected) {
            value_ = desired;
            return true;
        }
        expected = value_;
        return false;
    }

    bool compare_exchange_strong(T*& expected, T* desired,
                                 memory_order success = memory_order_seq_cst,
                                 memory_order failure = memory_order_seq_cst) noexcept {
        return compare_exchange_weak(expected, desired, success, failure);
    }

    operator T*() const noexcept { return load(); }
    T* operator=(T* desired) noexcept { store(desired); return desired; }

    T* fetch_add(long long arg, memory_order order = memory_order_seq_cst) noexcept {
        T* old = value_;
        value_ = value_ + arg;
        return old;
    }

    T* fetch_sub(long long arg, memory_order order = memory_order_seq_cst) noexcept {
        T* old = value_;
        value_ = value_ - arg;
        return old;
    }

    T* operator++() noexcept { return fetch_add(1) + 1; }
    T* operator++(int) noexcept { return fetch_add(1); }
    T* operator--() noexcept { return fetch_sub(1) - 1; }
    T* operator--(int) noexcept { return fetch_sub(1); }

    bool is_lock_free() const noexcept { return true; }

private:
    T* value_;
};

// Type aliases for common types
using atomic_bool = atomic<bool>;
using atomic_char = atomic<char>;
using atomic_schar = atomic<signed char>;
using atomic_uchar = atomic<unsigned char>;
using atomic_short = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int = atomic<int>;
using atomic_uint = atomic<unsigned int>;
using atomic_long = atomic<long>;
using atomic_ulong = atomic<unsigned long>;
using atomic_llong = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;

using atomic_int8_t = atomic<int8_t>;
using atomic_uint8_t = atomic<uint8_t>;
using atomic_int16_t = atomic<int16_t>;
using atomic_uint16_t = atomic<uint16_t>;
using atomic_int32_t = atomic<int32_t>;
using atomic_uint32_t = atomic<uint32_t>;
using atomic_int64_t = atomic<int64_t>;
using atomic_uint64_t = atomic<uint64_t>;

using atomic_size_t = atomic<size_t>;
using atomic_ptrdiff_t = atomic<long>;
using atomic_intptr_t = atomic<long>;
using atomic_uintptr_t = atomic<unsigned long>;

// Atomic flag (for spinlocks)
struct atomic_flag {
    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;

    bool test_and_set(memory_order order = memory_order_seq_cst) noexcept {
        bool old = flag_;
        flag_ = true;
        return old;
    }

    void clear(memory_order order = memory_order_seq_cst) noexcept {
        flag_ = false;
    }

    bool test(memory_order order = memory_order_seq_cst) const noexcept {
        return flag_;
    }

private:
    bool flag_ = false;
};

#define ATOMIC_FLAG_INIT {}

// Memory fence functions
inline void atomic_thread_fence(memory_order order) noexcept {}
inline void atomic_signal_fence(memory_order order) noexcept {}

} // namespace std

#endif // _FRAGILE_ATOMIC_
