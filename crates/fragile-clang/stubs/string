// Minimal string stub for fragile parsing
#ifndef _FRAGILE_STRING_
#define _FRAGILE_STRING_

#include "cstdint"

namespace std {

// Forward declarations
template<typename T> struct hash;
template<typename CharT> struct char_traits;

template<>
struct char_traits<char> {
    using char_type = char;
    using int_type = int;
    using pos_type = long;
    using off_type = long;

    static size_t length(const char* s) {
        size_t len = 0;
        while (s[len]) ++len;
        return len;
    }

    static int compare(const char* s1, const char* s2, size_t n) {
        for (size_t i = 0; i < n; ++i) {
            if (s1[i] < s2[i]) return -1;
            if (s1[i] > s2[i]) return 1;
        }
        return 0;
    }

    static char* copy(char* dest, const char* src, size_t n) {
        for (size_t i = 0; i < n; ++i) dest[i] = src[i];
        return dest;
    }

    static char* assign(char* s, size_t n, char c) {
        for (size_t i = 0; i < n; ++i) s[i] = c;
        return s;
    }
};

// basic_string
template<typename CharT, typename Traits = char_traits<CharT>, typename Allocator = void>
class basic_string {
public:
    using traits_type = Traits;
    using value_type = CharT;
    using size_type = size_t;
    using difference_type = long;
    using reference = CharT&;
    using const_reference = const CharT&;
    using pointer = CharT*;
    using const_pointer = const CharT*;
    using iterator = CharT*;
    using const_iterator = const CharT*;

    static constexpr size_type npos = static_cast<size_type>(-1);

    // Constructors
    basic_string() : data_(nullptr), size_(0), capacity_(0) {}

    basic_string(const CharT* s) {
        size_ = Traits::length(s);
        capacity_ = size_ + 1;
        data_ = new CharT[capacity_];
        Traits::copy(data_, s, size_);
        data_[size_] = CharT();
    }

    basic_string(const CharT* s, size_type n) : size_(n), capacity_(n + 1) {
        data_ = new CharT[capacity_];
        Traits::copy(data_, s, n);
        data_[size_] = CharT();
    }

    basic_string(size_type n, CharT c) : size_(n), capacity_(n + 1) {
        data_ = new CharT[capacity_];
        Traits::assign(data_, n, c);
        data_[size_] = CharT();
    }

    basic_string(const basic_string& other) : size_(other.size_), capacity_(other.capacity_) {
        data_ = new CharT[capacity_];
        Traits::copy(data_, other.data_, size_);
        data_[size_] = CharT();
    }

    basic_string(basic_string&& other) noexcept
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }

    // Iterator range constructor
    template<typename InputIt>
    basic_string(InputIt first, InputIt last) : data_(nullptr), size_(0), capacity_(0) {
        for (InputIt it = first; it != last; ++it) {
            push_back(*it);
        }
    }

    ~basic_string() { delete[] data_; }

    // Assignment
    basic_string& operator=(const basic_string& other) {
        if (this != &other) {
            delete[] data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            data_ = new CharT[capacity_];
            Traits::copy(data_, other.data_, size_);
            data_[size_] = CharT();
        }
        return *this;
    }

    basic_string& operator=(basic_string&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }

    basic_string& operator=(const CharT* s) {
        delete[] data_;
        size_ = Traits::length(s);
        capacity_ = size_ + 1;
        data_ = new CharT[capacity_];
        Traits::copy(data_, s, size_);
        data_[size_] = CharT();
        return *this;
    }

    // Element access
    reference operator[](size_type pos) { return data_[pos]; }
    const_reference operator[](size_type pos) const { return data_[pos]; }
    reference at(size_type pos) { return data_[pos]; }
    const_reference at(size_type pos) const { return data_[pos]; }
    reference front() { return data_[0]; }
    const_reference front() const { return data_[0]; }
    reference back() { return data_[size_ - 1]; }
    const_reference back() const { return data_[size_ - 1]; }
    // C++17: non-const data() for mutable access
    CharT* data() noexcept { return data_; }
    const CharT* data() const noexcept { return data_; }
    const CharT* c_str() const noexcept { return data_ ? data_ : ""; }

    // Iterators
    iterator begin() noexcept { return data_; }
    const_iterator begin() const noexcept { return data_; }
    const_iterator cbegin() const noexcept { return data_; }
    iterator end() noexcept { return data_ + size_; }
    const_iterator end() const noexcept { return data_ + size_; }
    const_iterator cend() const noexcept { return data_ + size_; }

    // Reverse iterators
    using reverse_iterator = CharT*;
    using const_reverse_iterator = const CharT*;

    reverse_iterator rbegin() noexcept { return data_ + size_ - 1; }
    const_reverse_iterator rbegin() const noexcept { return data_ + size_ - 1; }
    const_reverse_iterator crbegin() const noexcept { return data_ + size_ - 1; }
    reverse_iterator rend() noexcept { return data_ - 1; }
    const_reverse_iterator rend() const noexcept { return data_ - 1; }
    const_reverse_iterator crend() const noexcept { return data_ - 1; }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }
    size_type length() const noexcept { return size_; }
    size_type capacity() const noexcept { return capacity_; }

    void reserve(size_type new_cap) {
        if (new_cap > capacity_) {
            CharT* new_data = new CharT[new_cap];
            if (data_) {
                Traits::copy(new_data, data_, size_);
                delete[] data_;
            }
            data_ = new_data;
            capacity_ = new_cap;
        }
    }

    void resize(size_type count) { resize(count, CharT()); }
    void resize(size_type count, CharT ch) {
        if (count > capacity_) reserve(count + 1);
        if (count > size_) {
            Traits::assign(data_ + size_, count - size_, ch);
        }
        size_ = count;
        if (data_) data_[size_] = CharT();
    }

    void clear() noexcept { size_ = 0; if (data_) data_[0] = CharT(); }

    // Modifiers
    basic_string& operator+=(const basic_string& str) {
        return append(str);
    }

    basic_string& operator+=(const CharT* s) {
        return append(s);
    }

    basic_string& operator+=(CharT c) {
        push_back(c);
        return *this;
    }

    basic_string& append(const basic_string& str) {
        return append(str.data_, str.size_);
    }

    basic_string& append(const CharT* s) {
        return append(s, Traits::length(s));
    }

    basic_string& append(const CharT* s, size_type n) {
        size_type new_size = size_ + n;
        if (new_size >= capacity_) reserve(new_size * 2 + 1);
        Traits::copy(data_ + size_, s, n);
        size_ = new_size;
        data_[size_] = CharT();
        return *this;
    }

    void push_back(CharT c) {
        if (size_ + 1 >= capacity_) reserve((capacity_ ? capacity_ * 2 : 16));
        data_[size_++] = c;
        data_[size_] = CharT();
    }

    void pop_back() { if (size_ > 0) { --size_; data_[size_] = CharT(); } }

    // replace methods
    basic_string& replace(size_type pos, size_type count, const basic_string& str) {
        return replace(pos, count, str.data_, str.size_);
    }

    basic_string& replace(size_type pos, size_type count, const basic_string& str,
                         size_type pos2, size_type count2 = npos) {
        if (count2 == npos || pos2 + count2 > str.size_) count2 = str.size_ - pos2;
        return replace(pos, count, str.data_ + pos2, count2);
    }

    basic_string& replace(size_type pos, size_type count, const CharT* cstr, size_type count2) {
        if (pos > size_) pos = size_;
        if (pos + count > size_) count = size_ - pos;

        size_type new_size = size_ - count + count2;
        if (new_size >= capacity_) {
            CharT* new_data = new CharT[new_size + 1];
            Traits::copy(new_data, data_, pos);
            Traits::copy(new_data + pos, cstr, count2);
            Traits::copy(new_data + pos + count2, data_ + pos + count, size_ - pos - count);
            delete[] data_;
            data_ = new_data;
            capacity_ = new_size + 1;
        } else {
            // Move tail if needed
            if (count != count2) {
                for (size_type i = size_ - 1; i >= pos + count && i < size_; --i) {
                    data_[i - count + count2] = data_[i];
                }
            }
            Traits::copy(data_ + pos, cstr, count2);
        }
        size_ = new_size;
        data_[size_] = CharT();
        return *this;
    }

    basic_string& replace(size_type pos, size_type count, const CharT* cstr) {
        return replace(pos, count, cstr, Traits::length(cstr));
    }

    basic_string& replace(size_type pos, size_type count, size_type count2, CharT ch) {
        basic_string temp(count2, ch);
        return replace(pos, count, temp);
    }

    basic_string& replace(const_iterator first, const_iterator last, const basic_string& str) {
        size_type pos = first - data_;
        size_type count = last - first;
        return replace(pos, count, str);
    }

    basic_string& replace(const_iterator first, const_iterator last, const CharT* cstr, size_type count2) {
        size_type pos = first - data_;
        size_type count = last - first;
        return replace(pos, count, cstr, count2);
    }

    basic_string& replace(const_iterator first, const_iterator last, const CharT* cstr) {
        size_type pos = first - data_;
        size_type count = last - first;
        return replace(pos, count, cstr);
    }

    basic_string& replace(const_iterator first, const_iterator last, size_type count2, CharT ch) {
        size_type pos = first - data_;
        size_type count = last - first;
        return replace(pos, count, count2, ch);
    }

    // insert methods
    basic_string& insert(size_type pos, const basic_string& str) {
        return insert(pos, str.data_, str.size_);
    }

    basic_string& insert(size_type pos, const CharT* s) {
        return insert(pos, s, Traits::length(s));
    }

    basic_string& insert(size_type pos, const CharT* s, size_type count) {
        return replace(pos, 0, s, count);
    }

    basic_string& insert(size_type pos, size_type count, CharT ch) {
        return replace(pos, 0, count, ch);
    }

    // erase methods
    basic_string& erase(size_type pos = 0, size_type count = npos) {
        if (pos > size_) pos = size_;
        if (count == npos || pos + count > size_) count = size_ - pos;
        size_type tail_len = size_ - pos - count;
        for (size_type i = 0; i < tail_len; ++i) {
            data_[pos + i] = data_[pos + count + i];
        }
        size_ -= count;
        data_[size_] = CharT();
        return *this;
    }

    iterator erase(const_iterator position) {
        size_type pos = position - data_;
        erase(pos, 1);
        return data_ + pos;
    }

    iterator erase(const_iterator first, const_iterator last) {
        size_type pos = first - data_;
        size_type count = last - first;
        erase(pos, count);
        return data_ + pos;
    }

    // assign methods
    basic_string& assign(const basic_string& str) {
        return *this = str;
    }

    basic_string& assign(const basic_string& str, size_type pos, size_type count = npos) {
        if (count == npos || pos + count > str.size_) count = str.size_ - pos;
        return assign(str.data_ + pos, count);
    }

    basic_string& assign(const CharT* s, size_type count) {
        delete[] data_;
        size_ = count;
        capacity_ = count + 1;
        data_ = new CharT[capacity_];
        Traits::copy(data_, s, count);
        data_[size_] = CharT();
        return *this;
    }

    basic_string& assign(const CharT* s) {
        return assign(s, Traits::length(s));
    }

    basic_string& assign(size_type count, CharT ch) {
        delete[] data_;
        size_ = count;
        capacity_ = count + 1;
        data_ = new CharT[capacity_];
        Traits::assign(data_, count, ch);
        data_[size_] = CharT();
        return *this;
    }

    template<typename InputIt>
    basic_string& assign(InputIt first, InputIt last) {
        // Simplified: just handle as a range
        clear();
        for (; first != last; ++first) {
            push_back(*first);
        }
        return *this;
    }

    // String operations
    int compare(const basic_string& str) const {
        size_type len = size_ < str.size_ ? size_ : str.size_;
        int r = Traits::compare(data_, str.data_, len);
        if (r != 0) return r;
        if (size_ < str.size_) return -1;
        if (size_ > str.size_) return 1;
        return 0;
    }

    basic_string substr(size_type pos = 0, size_type count = npos) const {
        if (count == npos || pos + count > size_) count = size_ - pos;
        return basic_string(data_ + pos, count);
    }

    size_type find(const basic_string& str, size_type pos = 0) const {
        return find(str.data_, pos, str.size_);
    }

    size_type find(const CharT* s, size_type pos, size_type count) const {
        if (count == 0) return pos;
        if (pos + count > size_) return npos;
        for (size_type i = pos; i <= size_ - count; ++i) {
            if (Traits::compare(data_ + i, s, count) == 0) return i;
        }
        return npos;
    }

    size_type find(const CharT* s, size_type pos = 0) const {
        return find(s, pos, Traits::length(s));
    }

    size_type find(CharT c, size_type pos = 0) const {
        for (size_type i = pos; i < size_; ++i) {
            if (data_[i] == c) return i;
        }
        return npos;
    }

    size_type rfind(const basic_string& str, size_type pos = npos) const {
        return rfind(str.data_, pos, str.size_);
    }

    size_type rfind(const CharT* s, size_type pos, size_type count) const {
        if (count == 0) return (pos < size_) ? pos : size_;
        if (count > size_) return npos;
        size_type start = (pos < size_ - count) ? pos : size_ - count;
        for (size_type i = start + 1; i > 0; --i) {
            if (Traits::compare(data_ + i - 1, s, count) == 0) return i - 1;
        }
        return npos;
    }

    size_type rfind(const CharT* s, size_type pos = npos) const {
        return rfind(s, pos, Traits::length(s));
    }

    size_type rfind(CharT c, size_type pos = npos) const {
        if (size_ == 0) return npos;
        size_type start = (pos < size_) ? pos : size_ - 1;
        for (size_type i = start + 1; i > 0; --i) {
            if (data_[i - 1] == c) return i - 1;
        }
        return npos;
    }

    size_type find_first_of(const basic_string& str, size_type pos = 0) const {
        return find_first_of(str.data_, pos, str.size_);
    }

    size_type find_first_of(const CharT* s, size_type pos, size_type count) const {
        for (size_type i = pos; i < size_; ++i) {
            for (size_type j = 0; j < count; ++j) {
                if (data_[i] == s[j]) return i;
            }
        }
        return npos;
    }

    size_type find_first_of(const CharT* s, size_type pos = 0) const {
        return find_first_of(s, pos, Traits::length(s));
    }

    size_type find_first_of(CharT c, size_type pos = 0) const {
        return find(c, pos);
    }

    size_type find_last_of(const basic_string& str, size_type pos = npos) const {
        return find_last_of(str.data_, pos, str.size_);
    }

    size_type find_last_of(const CharT* s, size_type pos, size_type count) const {
        if (size_ == 0 || count == 0) return npos;
        size_type start = (pos < size_) ? pos : size_ - 1;
        for (size_type i = start + 1; i > 0; --i) {
            for (size_type j = 0; j < count; ++j) {
                if (data_[i - 1] == s[j]) return i - 1;
            }
        }
        return npos;
    }

    size_type find_last_of(const CharT* s, size_type pos = npos) const {
        return find_last_of(s, pos, Traits::length(s));
    }

    size_type find_last_of(CharT c, size_type pos = npos) const {
        return rfind(c, pos);
    }

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const {
        return find_first_not_of(str.data_, pos, str.size_);
    }

    size_type find_first_not_of(const CharT* s, size_type pos, size_type count) const {
        for (size_type i = pos; i < size_; ++i) {
            bool found = false;
            for (size_type j = 0; j < count; ++j) {
                if (data_[i] == s[j]) { found = true; break; }
            }
            if (!found) return i;
        }
        return npos;
    }

    size_type find_first_not_of(const CharT* s, size_type pos = 0) const {
        return find_first_not_of(s, pos, Traits::length(s));
    }

    size_type find_first_not_of(CharT c, size_type pos = 0) const {
        for (size_type i = pos; i < size_; ++i) {
            if (data_[i] != c) return i;
        }
        return npos;
    }

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const {
        return find_last_not_of(str.data_, pos, str.size_);
    }

    size_type find_last_not_of(const CharT* s, size_type pos, size_type count) const {
        if (size_ == 0) return npos;
        size_type start = (pos < size_) ? pos : size_ - 1;
        for (size_type i = start + 1; i > 0; --i) {
            bool found = false;
            for (size_type j = 0; j < count; ++j) {
                if (data_[i - 1] == s[j]) { found = true; break; }
            }
            if (!found) return i - 1;
        }
        return npos;
    }

    size_type find_last_not_of(const CharT* s, size_type pos = npos) const {
        return find_last_not_of(s, pos, Traits::length(s));
    }

    size_type find_last_not_of(CharT c, size_type pos = npos) const {
        if (size_ == 0) return npos;
        size_type start = (pos < size_) ? pos : size_ - 1;
        for (size_type i = start + 1; i > 0; --i) {
            if (data_[i - 1] != c) return i - 1;
        }
        return npos;
    }

    // Comparison operators
    bool operator==(const basic_string& other) const { return compare(other) == 0; }
    bool operator!=(const basic_string& other) const { return compare(other) != 0; }
    bool operator<(const basic_string& other) const { return compare(other) < 0; }
    bool operator<=(const basic_string& other) const { return compare(other) <= 0; }
    bool operator>(const basic_string& other) const { return compare(other) > 0; }
    bool operator>=(const basic_string& other) const { return compare(other) >= 0; }

    bool operator==(const CharT* s) const { return compare(basic_string(s)) == 0; }
    bool operator!=(const CharT* s) const { return compare(basic_string(s)) != 0; }

private:
    CharT* data_;
    size_type size_;
    size_type capacity_;
};

using string = basic_string<char>;
using wstring = basic_string<wchar_t>;

// Concatenation
template<typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(
    const basic_string<CharT, Traits, Alloc>& lhs,
    const basic_string<CharT, Traits, Alloc>& rhs) {
    basic_string<CharT, Traits, Alloc> result(lhs);
    result += rhs;
    return result;
}

template<typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(
    const basic_string<CharT, Traits, Alloc>& lhs,
    const CharT* rhs) {
    basic_string<CharT, Traits, Alloc> result(lhs);
    result += rhs;
    return result;
}

template<typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(
    const CharT* lhs,
    const basic_string<CharT, Traits, Alloc>& rhs) {
    basic_string<CharT, Traits, Alloc> result(lhs);
    result += rhs;
    return result;
}

// to_string
inline string to_string(int value) { return string("0"); }
inline string to_string(long value) { return string("0"); }
inline string to_string(long long value) { return string("0"); }
inline string to_string(unsigned value) { return string("0"); }
inline string to_string(unsigned long value) { return string("0"); }
inline string to_string(unsigned long long value) { return string("0"); }
inline string to_string(float value) { return string("0.0"); }
inline string to_string(double value) { return string("0.0"); }
inline string to_string(long double value) { return string("0.0"); }

// stoi, stol, etc. (minimal stubs)
inline int stoi(const string& str, size_t* pos = nullptr, int base = 10) { (void)str; (void)pos; (void)base; return 0; }
inline long stol(const string& str, size_t* pos = nullptr, int base = 10) { (void)str; (void)pos; (void)base; return 0; }
inline long long stoll(const string& str, size_t* pos = nullptr, int base = 10) { (void)str; (void)pos; (void)base; return 0; }

// Non-member comparison operators (const char* on left side)
template<typename CharT, typename Traits, typename Alloc>
bool operator==(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs == lhs;
}

template<typename CharT, typename Traits, typename Alloc>
bool operator!=(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs != lhs;
}

template<typename CharT, typename Traits, typename Alloc>
bool operator<(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs > lhs;
}

template<typename CharT, typename Traits, typename Alloc>
bool operator>(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs < lhs;
}

template<typename CharT, typename Traits, typename Alloc>
bool operator<=(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs >= lhs;
}

template<typename CharT, typename Traits, typename Alloc>
bool operator>=(const CharT* lhs, const basic_string<CharT, Traits, Alloc>& rhs) {
    return rhs <= lhs;
}

// hash specialization for string
template<>
struct hash<string> {
    size_t operator()(const string& s) const noexcept {
        size_t h = 0;
        for (size_t i = 0; i < s.size(); ++i) {
            h = h * 31 + static_cast<size_t>(s[i]);
        }
        return h;
    }
};

// Forward declarations for I/O (full definitions in iostream/sstream)
template<typename CharT, typename Traits> class basic_istream;

// getline - reads from input stream into string
template<typename CharT, typename Traits, typename Alloc>
basic_istream<CharT, Traits>& getline(
    basic_istream<CharT, Traits>& input,
    basic_string<CharT, Traits, Alloc>& str,
    CharT delim) {
    str.clear();
    // Stub implementation - just return the stream
    (void)delim;
    return input;
}

template<typename CharT, typename Traits, typename Alloc>
basic_istream<CharT, Traits>& getline(
    basic_istream<CharT, Traits>& input,
    basic_string<CharT, Traits, Alloc>& str) {
    return getline(input, str, CharT('\n'));
}

} // namespace std

#endif // _FRAGILE_STRING_
