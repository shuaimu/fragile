// Minimal vector stub for fragile parsing
#ifndef _FRAGILE_VECTOR_
#define _FRAGILE_VECTOR_

#include "cstdint"
#include "initializer_list"
#include "iterator"
#include "memory"

namespace std {

template<typename T, typename Allocator = void>
class vector {
public:
    using value_type = T;
    using size_type = size_t;
    using difference_type = long;
    using reference = T&;
    using const_reference = const T&;
    using pointer = T*;
    using const_pointer = const T*;
    using iterator = T*;
    using const_iterator = const T*;

    // Constructors
    vector() : data_(nullptr), size_(0), capacity_(0) {}

    explicit vector(size_type count) : size_(count), capacity_(count) {
        data_ = count > 0 ? new T[count]() : nullptr;
    }

    vector(size_type count, const T& value) : size_(count), capacity_(count) {
        data_ = count > 0 ? new T[count] : nullptr;
        for (size_type i = 0; i < count; ++i) data_[i] = value;
    }

    vector(std::initializer_list<T> init) : size_(init.size()), capacity_(init.size()) {
        data_ = size_ > 0 ? new T[size_] : nullptr;
        size_type i = 0;
        for (const auto& v : init) data_[i++] = v;
    }

    template<typename InputIt>
    vector(InputIt first, InputIt last) : data_(nullptr), size_(0), capacity_(0) {
        for (; first != last; ++first) push_back(*first);
    }

    vector(const vector& other) : size_(other.size_), capacity_(other.capacity_) {
        data_ = capacity_ > 0 ? new T[capacity_] : nullptr;
        for (size_type i = 0; i < size_; ++i) data_[i] = other.data_[i];
    }

    vector(vector&& other) noexcept
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }

    ~vector() { delete[] data_; }

    // Assignment
    vector& operator=(const vector& other) {
        if (this != &other) {
            delete[] data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            data_ = capacity_ > 0 ? new T[capacity_] : nullptr;
            for (size_type i = 0; i < size_; ++i) data_[i] = other.data_[i];
        }
        return *this;
    }

    vector& operator=(vector&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }

    // Element access
    reference operator[](size_type pos) { return data_[pos]; }
    const_reference operator[](size_type pos) const { return data_[pos]; }
    reference at(size_type pos) { return data_[pos]; }
    const_reference at(size_type pos) const { return data_[pos]; }
    reference front() { return data_[0]; }
    const_reference front() const { return data_[0]; }
    reference back() { return data_[size_ - 1]; }
    const_reference back() const { return data_[size_ - 1]; }
    T* data() noexcept { return data_; }
    const T* data() const noexcept { return data_; }

    // Iterators
    iterator begin() noexcept { return data_; }
    const_iterator begin() const noexcept { return data_; }
    const_iterator cbegin() const noexcept { return data_; }
    iterator end() noexcept { return data_ + size_; }
    const_iterator end() const noexcept { return data_ + size_; }
    const_iterator cend() const noexcept { return data_ + size_; }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }
    size_type capacity() const noexcept { return capacity_; }

    void reserve(size_type new_cap) {
        if (new_cap > capacity_) {
            T* new_data = new T[new_cap];
            for (size_type i = 0; i < size_; ++i) {
                new_data[i] = static_cast<T&&>(data_[i]);
            }
            delete[] data_;
            data_ = new_data;
            capacity_ = new_cap;
        }
    }

    void resize(size_type count) { resize(count, T()); }

    void resize(size_type count, const T& value) {
        if (count > capacity_) reserve(count);
        for (size_type i = size_; i < count; ++i) data_[i] = value;
        size_ = count;
    }

    void shrink_to_fit() {
        if (size_ < capacity_) {
            T* new_data = size_ > 0 ? new T[size_] : nullptr;
            for (size_type i = 0; i < size_; ++i) {
                new_data[i] = static_cast<T&&>(data_[i]);
            }
            delete[] data_;
            data_ = new_data;
            capacity_ = size_;
        }
    }

    // Modifiers
    void clear() noexcept { size_ = 0; }

    void assign(size_type count, const T& value) {
        clear();
        if (count > capacity_) {
            delete[] data_;
            data_ = new T[count];
            capacity_ = count;
        }
        for (size_type i = 0; i < count; ++i) data_[i] = value;
        size_ = count;
    }

    template<typename InputIt>
    void assign(InputIt first, InputIt last) {
        clear();
        for (; first != last; ++first) push_back(*first);
    }

    void assign(std::initializer_list<T> ilist) {
        clear();
        if (ilist.size() > capacity_) {
            delete[] data_;
            data_ = new T[ilist.size()];
            capacity_ = ilist.size();
        }
        size_type i = 0;
        for (const auto& v : ilist) data_[i++] = v;
        size_ = ilist.size();
    }

    void push_back(const T& value) {
        if (size_ >= capacity_) reserve(capacity_ ? capacity_ * 2 : 8);
        data_[size_++] = value;
    }

    void push_back(T&& value) {
        if (size_ >= capacity_) reserve(capacity_ ? capacity_ * 2 : 8);
        data_[size_++] = static_cast<T&&>(value);
    }

    template<typename... Args>
    reference emplace_back(Args&&... args) {
        if (size_ >= capacity_) reserve(capacity_ ? capacity_ * 2 : 8);
        data_[size_] = T(static_cast<Args&&>(args)...);
        return data_[size_++];
    }

    void pop_back() { if (size_ > 0) --size_; }

    iterator erase(const_iterator pos) {
        size_type idx = pos - data_;
        for (size_type i = idx; i < size_ - 1; ++i) {
            data_[i] = static_cast<T&&>(data_[i + 1]);
        }
        --size_;
        return data_ + idx;
    }

    iterator erase(const_iterator first, const_iterator last) {
        size_type start = first - data_;
        size_type count = last - first;
        for (size_type i = start; i < size_ - count; ++i) {
            data_[i] = static_cast<T&&>(data_[i + count]);
        }
        size_ -= count;
        return data_ + start;
    }

    iterator insert(const_iterator pos, const T& value) {
        size_type idx = pos - data_;
        if (size_ >= capacity_) reserve(capacity_ ? capacity_ * 2 : 8);
        for (size_type i = size_; i > idx; --i) {
            data_[i] = static_cast<T&&>(data_[i - 1]);
        }
        data_[idx] = value;
        ++size_;
        return data_ + idx;
    }

    template<typename InputIt>
    iterator insert(const_iterator pos, InputIt first, InputIt last) {
        size_type idx = pos - data_;
        size_type count = 0;
        for (InputIt it = first; it != last; ++it) ++count;
        if (size_ + count > capacity_) reserve(size_ + count);
        for (size_type i = size_ + count - 1; i >= idx + count && i < size_ + count; --i) {
            data_[i] = static_cast<T&&>(data_[i - count]);
        }
        size_type i = idx;
        for (; first != last; ++first) {
            data_[i++] = *first;
        }
        size_ += count;
        return data_ + idx;
    }

    void swap(vector& other) noexcept {
        T* tmp_data = data_;
        size_type tmp_size = size_;
        size_type tmp_cap = capacity_;
        data_ = other.data_;
        size_ = other.size_;
        capacity_ = other.capacity_;
        other.data_ = tmp_data;
        other.size_ = tmp_size;
        other.capacity_ = tmp_cap;
    }

    // Comparison
    bool operator==(const vector& other) const {
        if (size_ != other.size_) return false;
        for (size_type i = 0; i < size_; ++i) {
            if (!(data_[i] == other.data_[i])) return false;
        }
        return true;
    }

    bool operator!=(const vector& other) const { return !(*this == other); }

private:
    T* data_;
    size_type size_;
    size_type capacity_;
};

} // namespace std

#endif // _FRAGILE_VECTOR_
