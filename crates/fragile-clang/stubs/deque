// Minimal deque stub for fragile parsing
#ifndef _FRAGILE_DEQUE_
#define _FRAGILE_DEQUE_

#include "cstdint"
#include "iterator"

namespace std {

template<typename T, typename Allocator = void>
class deque {
public:
    using value_type = T;
    using allocator_type = Allocator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using reference = T&;
    using const_reference = const T&;
    using pointer = T*;
    using const_pointer = const T*;
    using iterator = T*;
    using const_iterator = const T*;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // Constructors
    deque() : data_(nullptr), size_(0), capacity_(0) {}

    explicit deque(size_type count) : size_(count), capacity_(count) {
        data_ = count > 0 ? new T[count]() : nullptr;
    }

    deque(size_type count, const T& value) : size_(count), capacity_(count) {
        data_ = count > 0 ? new T[count] : nullptr;
        for (size_type i = 0; i < count; ++i) {
            data_[i] = value;
        }
    }

    deque(const deque& other) : size_(other.size_), capacity_(other.capacity_) {
        data_ = capacity_ > 0 ? new T[capacity_] : nullptr;
        for (size_type i = 0; i < size_; ++i) {
            data_[i] = other.data_[i];
        }
    }

    deque(deque&& other) noexcept
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }

    ~deque() { delete[] data_; }

    deque& operator=(const deque& other) {
        if (this != &other) {
            delete[] data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            data_ = capacity_ > 0 ? new T[capacity_] : nullptr;
            for (size_type i = 0; i < size_; ++i) {
                data_[i] = other.data_[i];
            }
        }
        return *this;
    }

    deque& operator=(deque&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }

    // Element access
    reference at(size_type pos) { return data_[pos]; }
    const_reference at(size_type pos) const { return data_[pos]; }
    reference operator[](size_type pos) { return data_[pos]; }
    const_reference operator[](size_type pos) const { return data_[pos]; }
    reference front() { return data_[0]; }
    const_reference front() const { return data_[0]; }
    reference back() { return data_[size_ - 1]; }
    const_reference back() const { return data_[size_ - 1]; }

    // Iterators
    iterator begin() noexcept { return data_; }
    const_iterator begin() const noexcept { return data_; }
    const_iterator cbegin() const noexcept { return data_; }
    iterator end() noexcept { return data_ + size_; }
    const_iterator end() const noexcept { return data_ + size_; }
    const_iterator cend() const noexcept { return data_ + size_; }
    reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
    reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }
    size_type max_size() const noexcept { return static_cast<size_type>(-1) / sizeof(T); }
    void shrink_to_fit() {}

    // Modifiers
    void clear() noexcept { size_ = 0; }

    void push_back(const T& value) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        data_[size_++] = value;
    }

    void push_back(T&& value) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        data_[size_++] = static_cast<T&&>(value);
    }

    template<typename... Args>
    reference emplace_back(Args&&... args) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        new (&data_[size_]) T(static_cast<Args&&>(args)...);
        return data_[size_++];
    }

    void pop_back() {
        if (size_ > 0) --size_;
    }

    void push_front(const T& value) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        // Shift elements right
        for (size_type i = size_; i > 0; --i) {
            data_[i] = static_cast<T&&>(data_[i - 1]);
        }
        data_[0] = value;
        ++size_;
    }

    void push_front(T&& value) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        // Shift elements right
        for (size_type i = size_; i > 0; --i) {
            data_[i] = static_cast<T&&>(data_[i - 1]);
        }
        data_[0] = static_cast<T&&>(value);
        ++size_;
    }

    template<typename... Args>
    reference emplace_front(Args&&... args) {
        if (size_ >= capacity_) {
            grow(capacity_ == 0 ? 1 : capacity_ * 2);
        }
        // Shift elements right
        for (size_type i = size_; i > 0; --i) {
            data_[i] = static_cast<T&&>(data_[i - 1]);
        }
        new (&data_[0]) T(static_cast<Args&&>(args)...);
        ++size_;
        return data_[0];
    }

    void pop_front() {
        if (size_ > 0) {
            // Shift elements left
            for (size_type i = 0; i + 1 < size_; ++i) {
                data_[i] = static_cast<T&&>(data_[i + 1]);
            }
            --size_;
        }
    }

    void resize(size_type count) {
        if (count > capacity_) grow(count);
        size_ = count;
    }

    void resize(size_type count, const value_type& value) {
        if (count > capacity_) grow(count);
        for (size_type i = size_; i < count; ++i) {
            data_[i] = value;
        }
        size_ = count;
    }

    void swap(deque& other) noexcept {
        T* tmp_data = data_;
        size_type tmp_size = size_;
        size_type tmp_cap = capacity_;
        data_ = other.data_;
        size_ = other.size_;
        capacity_ = other.capacity_;
        other.data_ = tmp_data;
        other.size_ = tmp_size;
        other.capacity_ = tmp_cap;
    }

    // Insert methods
    iterator insert(const_iterator pos, const T& value) {
        size_type idx = pos - data_;
        if (size_ >= capacity_) grow(capacity_ == 0 ? 1 : capacity_ * 2);
        for (size_type i = size_; i > idx; --i) {
            data_[i] = static_cast<T&&>(data_[i - 1]);
        }
        data_[idx] = value;
        ++size_;
        return data_ + idx;
    }

    template<typename InputIt>
    iterator insert(const_iterator pos, InputIt first, InputIt last) {
        size_type idx = pos - data_;
        size_type count = 0;
        // First count the elements to insert
        for (InputIt it = first; it != last; ++it) ++count;
        if (size_ + count > capacity_) grow(size_ + count);
        // Shift existing elements
        for (size_type i = size_ + count - 1; i >= idx + count && i < size_ + count; --i) {
            data_[i] = static_cast<T&&>(data_[i - count]);
        }
        // Insert new elements
        size_type i = idx;
        for (; first != last; ++first) {
            data_[i++] = *first;
        }
        size_ += count;
        return data_ + idx;
    }

private:
    void grow(size_type new_cap) {
        T* new_data = new T[new_cap];
        for (size_type i = 0; i < size_; ++i) {
            new_data[i] = static_cast<T&&>(data_[i]);
        }
        delete[] data_;
        data_ = new_data;
        capacity_ = new_cap;
    }

    T* data_;
    size_type size_;
    size_type capacity_;
};

template<typename T, typename Alloc>
bool operator==(const deque<T, Alloc>& lhs, const deque<T, Alloc>& rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (size_t i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i]) return false;
    }
    return true;
}

template<typename T, typename Alloc>
bool operator!=(const deque<T, Alloc>& lhs, const deque<T, Alloc>& rhs) {
    return !(lhs == rhs);
}

} // namespace std

#endif // _FRAGILE_DEQUE_
