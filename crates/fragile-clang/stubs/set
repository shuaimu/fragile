// Minimal set stub for fragile parsing
#ifndef _FRAGILE_SET_
#define _FRAGILE_SET_

#include "cstdint"
#include "utility"
#include "initializer_list"

namespace std {

template<typename Key, typename Compare = void, typename Allocator = void>
class set {
public:
    using key_type = Key;
    using value_type = Key;
    using size_type = size_t;
    using difference_type = long;
    using key_compare = Compare;
    using reference = value_type&;
    using const_reference = const value_type&;

private:
    struct node {
        value_type data;
        node* left;
        node* right;
        node* parent;
        node(const Key& k) : data(k), left(nullptr), right(nullptr), parent(nullptr) {}
    };

public:
    class iterator {
    public:
        iterator(node* n = nullptr) : node_(n) {}
        const_reference operator*() const { return node_->data; }
        const value_type* operator->() const { return &node_->data; }
        iterator& operator++() {
            if (node_->right) {
                node_ = node_->right;
                while (node_->left) node_ = node_->left;
            } else {
                while (node_->parent && node_ == node_->parent->right)
                    node_ = node_->parent;
                node_ = node_->parent;
            }
            return *this;
        }
        iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }
        bool operator==(const iterator& other) const { return node_ == other.node_; }
        bool operator!=(const iterator& other) const { return node_ != other.node_; }
    private:
        node* node_;
        friend class set;
    };

    using const_iterator = iterator;

    class reverse_iterator {
    public:
        reverse_iterator(node* n = nullptr) : node_(n) {}
        const_reference operator*() const { return node_->data; }
        const value_type* operator->() const { return &node_->data; }
        reverse_iterator& operator++() {
            if (node_->left) {
                node_ = node_->left;
                while (node_->right) node_ = node_->right;
            } else {
                while (node_->parent && node_ == node_->parent->left)
                    node_ = node_->parent;
                node_ = node_->parent;
            }
            return *this;
        }
        reverse_iterator operator++(int) { reverse_iterator tmp = *this; ++(*this); return tmp; }
        bool operator==(const reverse_iterator& other) const { return node_ == other.node_; }
        bool operator!=(const reverse_iterator& other) const { return node_ != other.node_; }
    private:
        node* node_;
        friend class set;
    };

    using const_reverse_iterator = reverse_iterator;

    // Constructors
    set() : root_(nullptr), size_(0) {}

    set(const set& other) : root_(nullptr), size_(0) {
        for (const auto& v : other) insert(v);
    }

    set(set&& other) noexcept : root_(other.root_), size_(other.size_) {
        other.root_ = nullptr;
        other.size_ = 0;
    }

    set(std::initializer_list<value_type> init) : root_(nullptr), size_(0) {
        for (const auto& v : init) insert(v);
    }

    template<typename InputIt>
    set(InputIt first, InputIt last) : root_(nullptr), size_(0) {
        for (; first != last; ++first) insert(*first);
    }

    ~set() { clear(); }

    // Assignment
    set& operator=(const set& other) {
        if (this != &other) {
            clear();
            for (const auto& v : other) insert(v);
        }
        return *this;
    }

    set& operator=(set&& other) noexcept {
        if (this != &other) {
            clear();
            root_ = other.root_;
            size_ = other.size_;
            other.root_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }

    // Iterators
    iterator begin() noexcept {
        node* n = root_;
        while (n && n->left) n = n->left;
        return iterator(n);
    }
    const_iterator begin() const noexcept {
        node* n = root_;
        while (n && n->left) n = n->left;
        return const_iterator(n);
    }
    const_iterator cbegin() const noexcept { return begin(); }
    iterator end() noexcept { return iterator(nullptr); }
    const_iterator end() const noexcept { return const_iterator(nullptr); }
    const_iterator cend() const noexcept { return const_iterator(nullptr); }

    reverse_iterator rbegin() noexcept {
        node* n = root_;
        while (n && n->right) n = n->right;
        return reverse_iterator(n);
    }
    const_reverse_iterator rbegin() const noexcept {
        node* n = root_;
        while (n && n->right) n = n->right;
        return const_reverse_iterator(n);
    }
    const_reverse_iterator crbegin() const noexcept { return rbegin(); }
    reverse_iterator rend() noexcept { return reverse_iterator(nullptr); }
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(nullptr); }
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(nullptr); }

    // Capacity
    bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }

    // Modifiers
    void clear() noexcept {
        clear_recursive(root_);
        root_ = nullptr;
        size_ = 0;
    }

    pair<iterator, bool> insert(const value_type& value) {
        if (!root_) {
            root_ = new node(value);
            ++size_;
            return make_pair(iterator(root_), true);
        }
        node* current = root_;
        node* parent = nullptr;
        while (current) {
            parent = current;
            if (value < current->data) {
                current = current->left;
            } else if (current->data < value) {
                current = current->right;
            } else {
                return make_pair(iterator(current), false);
            }
        }
        node* n = new node(value);
        n->parent = parent;
        if (value < parent->data) {
            parent->left = n;
        } else {
            parent->right = n;
        }
        ++size_;
        return make_pair(iterator(n), true);
    }

    template<typename... Args>
    pair<iterator, bool> emplace(Args&&... args) {
        return insert(value_type(static_cast<Args&&>(args)...));
    }

    iterator erase(const_iterator pos) {
        --size_;
        return end();
    }

    size_type erase(const Key& key) {
        auto it = find(key);
        if (it != end()) {
            erase(it);
            return 1;
        }
        return 0;
    }

    // Lookup
    iterator find(const Key& key) {
        node* current = root_;
        while (current) {
            if (key < current->data) {
                current = current->left;
            } else if (current->data < key) {
                current = current->right;
            } else {
                return iterator(current);
            }
        }
        return end();
    }

    const_iterator find(const Key& key) const {
        const node* current = root_;
        while (current) {
            if (key < current->data) {
                current = current->left;
            } else if (current->data < key) {
                current = current->right;
            } else {
                return const_iterator(current);
            }
        }
        return end();
    }

    size_type count(const Key& key) const {
        return find(key) != end() ? 1 : 0;
    }

private:
    void clear_recursive(node* n) {
        if (n) {
            clear_recursive(n->left);
            clear_recursive(n->right);
            delete n;
        }
    }

    node* root_;
    size_type size_;
};

// multiset (minimal stub)
template<typename Key, typename Compare = void, typename Allocator = void>
class multiset : public set<Key, Compare, Allocator> {
public:
    using set<Key, Compare, Allocator>::set;
};

} // namespace std

#endif // _FRAGILE_SET_
