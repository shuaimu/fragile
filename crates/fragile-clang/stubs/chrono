// Minimal chrono stub for fragile parsing
#ifndef _FRAGILE_CHRONO_
#define _FRAGILE_CHRONO_

#include "cstdint"
#include "algorithm"  // For std::max/min used with durations

namespace std {
namespace chrono {

// Duration
template<typename Rep, typename Period = void>
class duration {
public:
    using rep = Rep;
    using period = Period;

    constexpr duration() = default;
    constexpr explicit duration(const Rep& r) : rep_(r) {}

    template<typename Rep2, typename Period2>
    constexpr duration(const duration<Rep2, Period2>& d) : rep_(static_cast<Rep>(d.count())) {}

    constexpr rep count() const { return rep_; }

    constexpr duration operator+() const { return *this; }
    constexpr duration operator-() const { return duration(-rep_); }

    duration& operator++() { ++rep_; return *this; }
    duration operator++(int) { return duration(rep_++); }
    duration& operator--() { --rep_; return *this; }
    duration operator--(int) { return duration(rep_--); }

    duration& operator+=(const duration& d) { rep_ += d.count(); return *this; }
    duration& operator-=(const duration& d) { rep_ -= d.count(); return *this; }
    duration& operator*=(const rep& r) { rep_ *= r; return *this; }
    duration& operator/=(const rep& r) { rep_ /= r; return *this; }

private:
    rep rep_{};
};

// Common duration types
// Note: Use long instead of long long for compatibility with libc++ on some systems
// where duration::count() returns long (matching 1L literal type)
using nanoseconds = duration<long>;
using microseconds = duration<long>;
using milliseconds = duration<long>;
using seconds = duration<long>;
using minutes = duration<long>;
using hours = duration<long>;

// duration_cast
template<typename ToDuration, typename Rep, typename Period>
constexpr ToDuration duration_cast(const duration<Rep, Period>& d) {
    return ToDuration(static_cast<typename ToDuration::rep>(d.count()));
}

// Forward declaration for time_point_cast
template<typename Clock, typename Duration> class time_point;

// time_point_cast
template<typename ToDuration, typename Clock, typename Duration>
constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t) {
    return time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()));
}

// Time point
template<typename Clock, typename Duration = typename Clock::duration>
class time_point {
public:
    using clock = Clock;
    using duration = Duration;
    using rep = typename duration::rep;
    using period = typename duration::period;

    constexpr time_point() : d_() {}
    constexpr explicit time_point(const duration& d) : d_(d) {}

    template<typename Duration2>
    constexpr time_point(const time_point<Clock, Duration2>& t)
        : d_(t.time_since_epoch()) {}

    constexpr duration time_since_epoch() const { return d_; }

    time_point& operator+=(const duration& d) { d_ += d; return *this; }
    time_point& operator-=(const duration& d) { d_ -= d; return *this; }

private:
    duration d_;
};

// Clocks
class system_clock {
public:
    using duration = chrono::milliseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = chrono::time_point<system_clock>;

    static constexpr bool is_steady = false;

    static time_point now() noexcept { return time_point(); }

    // Convert time_point to std::time_t
    static long to_time_t(const time_point& t) noexcept {
        return static_cast<long>(t.time_since_epoch().count() / 1000);  // ms to seconds
    }

    // Convert std::time_t to time_point
    static time_point from_time_t(long t) noexcept {
        return time_point(duration(t * 1000));  // seconds to ms
    }
};

class steady_clock {
public:
    using duration = chrono::nanoseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = chrono::time_point<steady_clock>;

    static constexpr bool is_steady = true;

    static time_point now() noexcept { return time_point(); }
};

class high_resolution_clock {
public:
    using duration = chrono::nanoseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = chrono::time_point<high_resolution_clock>;

    static constexpr bool is_steady = true;

    static time_point now() noexcept { return time_point(); }
};

// Duration arithmetic operators (non-member)
template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr duration<long long> operator-(const duration<Rep1, Period1>& lhs,
                                        const duration<Rep2, Period2>& rhs) {
    return duration<long long>(lhs.count() - rhs.count());
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr duration<long long> operator+(const duration<Rep1, Period1>& lhs,
                                        const duration<Rep2, Period2>& rhs) {
    return duration<long long>(lhs.count() + rhs.count());
}

// Time point operators
template<typename Clock, typename Dur1, typename Dur2>
constexpr duration<long long> operator-(const time_point<Clock, Dur1>& lhs,
                                        const time_point<Clock, Dur2>& rhs) {
    return duration<long long>(lhs.time_since_epoch().count() - rhs.time_since_epoch().count());
}

// Duration comparison operators
template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs,
                          const duration<Rep2, Period2>& rhs) {
    return lhs.count() == rhs.count();
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator!=(const duration<Rep1, Period1>& lhs,
                          const duration<Rep2, Period2>& rhs) {
    return !(lhs == rhs);
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator<(const duration<Rep1, Period1>& lhs,
                         const duration<Rep2, Period2>& rhs) {
    return lhs.count() < rhs.count();
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
                          const duration<Rep2, Period2>& rhs) {
    return !(rhs < lhs);
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator>(const duration<Rep1, Period1>& lhs,
                         const duration<Rep2, Period2>& rhs) {
    return rhs < lhs;
}

template<typename Rep1, typename Period1, typename Rep2, typename Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
                          const duration<Rep2, Period2>& rhs) {
    return !(lhs < rhs);
}

// Time point comparison operators
template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator==(const time_point<Clock, Dur1>& lhs,
                          const time_point<Clock, Dur2>& rhs) {
    return lhs.time_since_epoch() == rhs.time_since_epoch();
}

template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator!=(const time_point<Clock, Dur1>& lhs,
                          const time_point<Clock, Dur2>& rhs) {
    return !(lhs == rhs);
}

template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator<(const time_point<Clock, Dur1>& lhs,
                         const time_point<Clock, Dur2>& rhs) {
    return lhs.time_since_epoch() < rhs.time_since_epoch();
}

template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator<=(const time_point<Clock, Dur1>& lhs,
                          const time_point<Clock, Dur2>& rhs) {
    return !(rhs < lhs);
}

template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator>(const time_point<Clock, Dur1>& lhs,
                         const time_point<Clock, Dur2>& rhs) {
    return rhs < lhs;
}

template<typename Clock, typename Dur1, typename Dur2>
constexpr bool operator>=(const time_point<Clock, Dur1>& lhs,
                          const time_point<Clock, Dur2>& rhs) {
    return !(lhs < rhs);
}

// Time point arithmetic with duration
template<typename Clock, typename Dur1, typename Rep2, typename Period2>
constexpr time_point<Clock, Dur1> operator+(const time_point<Clock, Dur1>& lhs,
                                            const duration<Rep2, Period2>& rhs) {
    return time_point<Clock, Dur1>(lhs.time_since_epoch() + rhs);
}

template<typename Rep1, typename Period1, typename Clock, typename Dur2>
constexpr time_point<Clock, Dur2> operator+(const duration<Rep1, Period1>& lhs,
                                            const time_point<Clock, Dur2>& rhs) {
    return rhs + lhs;
}

template<typename Clock, typename Dur1, typename Rep2, typename Period2>
constexpr time_point<Clock, Dur1> operator-(const time_point<Clock, Dur1>& lhs,
                                            const duration<Rep2, Period2>& rhs) {
    return time_point<Clock, Dur1>(lhs.time_since_epoch() - rhs);
}

} // namespace chrono
} // namespace std

#endif // _FRAGILE_CHRONO_
