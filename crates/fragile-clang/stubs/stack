// Minimal stack stub for fragile parsing
#ifndef _FRAGILE_STACK_
#define _FRAGILE_STACK_

#include "deque"

namespace std {

template<typename T, typename Container = deque<T>>
class stack {
public:
    using container_type = Container;
    using value_type = typename Container::value_type;
    using size_type = typename Container::size_type;
    using reference = typename Container::reference;
    using const_reference = typename Container::const_reference;

    stack() : c() {}
    explicit stack(const Container& cont) : c(cont) {}
    explicit stack(Container&& cont) : c(static_cast<Container&&>(cont)) {}

    stack(const stack& other) = default;
    stack(stack&& other) = default;
    stack& operator=(const stack& other) = default;
    stack& operator=(stack&& other) = default;

    // Element access
    reference top() { return c.back(); }
    const_reference top() const { return c.back(); }

    // Capacity
    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }

    // Modifiers
    void push(const value_type& value) { c.push_back(value); }
    void push(value_type&& value) { c.push_back(static_cast<value_type&&>(value)); }

    template<typename... Args>
    void emplace(Args&&... args) {
        c.emplace_back(static_cast<Args&&>(args)...);
    }

    void pop() { c.pop_back(); }

    void swap(stack& other) noexcept {
        using std::swap;
        swap(c, other.c);
    }

protected:
    Container c;
};

template<typename T, typename Container>
bool operator==(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c == rhs.c;
}

template<typename T, typename Container>
bool operator!=(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c != rhs.c;
}

template<typename T, typename Container>
bool operator<(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c < rhs.c;
}

template<typename T, typename Container>
bool operator<=(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c <= rhs.c;
}

template<typename T, typename Container>
bool operator>(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c > rhs.c;
}

template<typename T, typename Container>
bool operator>=(const stack<T, Container>& lhs, const stack<T, Container>& rhs) {
    return lhs.c >= rhs.c;
}

template<typename T, typename Container>
void swap(stack<T, Container>& lhs, stack<T, Container>& rhs) noexcept {
    lhs.swap(rhs);
}

} // namespace std

#endif // _FRAGILE_STACK_
