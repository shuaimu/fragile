=== Arrow Operator Test Log ===
Date: Thu Jan 22 04:20:01 PM EST 2026
Commit: d6c7d9c

=== Test Suite ===

running 27 tests
test ast_codegen::tests::test_if_statement ... ok
test ast_codegen::tests::test_simple_function ... ok
test types::tests::test_bit_width_no_fixed_width ... ok
test types::tests::test_bit_width_pointer_and_reference ... ok
test types::tests::test_bit_width_primitive_types ... ok
test types::tests::test_is_signed_integer_types ... ok
test types::tests::test_smart_pointer_type_mappings ... ok
test parse::tests::test_parse_anonymous_namespace ... ok
test parse::tests::test_float_literal_type_double ... ok
test parse::tests::test_bool_literal_false ... ok
test parse::tests::test_parse_using_nested_namespace ... ok
test parse::tests::test_string_literal ... ok
test parse::tests::test_parse_constructor_with_initializer_list ... ok
test parse::tests::test_parse_simple_function ... ok
test parse::tests::test_parse_const_lvalue_reference_parameter ... ok
test parse::tests::test_parse_rvalue_reference_parameter ... ok
test parse::tests::test_integer_literal_type_unsigned ... ok
test parse::tests::test_mangled_name_for_simple_function ... ok
test parse::tests::test_bool_literal_true ... ok
test parse::tests::test_string_literal_empty ... ok
test parse::tests::test_integer_literal_type_long ... ok
test parse::tests::test_parse_using_namespace ... ok
test parse::tests::test_float_literal_type_float ... ok
test parse::tests::test_parse_namespace ... ok
test parse::tests::test_parse_lvalue_reference_parameter ... ok
test parse::tests::test_integer_literal_type_int ... ok
test parse::tests::test_integer_literal_type_unsigned_long ... ok

test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s


running 20 tests
test test_16_references ... ok
test test_07_for_loop ... ok
test test_05_if_else ... ok
test test_01_arithmetic ... ok
test test_19_do_while ... ok
test test_06_while_loop ... ok
test test_18_ternary ... ok
test test_11_recursion ... ok
test test_20_nested_struct ... ok
test test_09_break_continue ... ok
test test_04_bitwise ... ok
test test_08_nested_loops ... ok
test test_15_pointers ... ok
test test_10_functions ... ok
test test_13_struct_methods ... ok
test test_03_logical ... ok
test test_12_struct_basic ... ok
test test_14_struct_constructor ... ok
test test_02_comparisons ... ok
test test_17_arrays ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.47s


running 54 tests
test test_control_flow ... ok
test test_end_to_end ... ok
test test_namespace_function ... ok
test test_parse_add_function ... ok
test test_generate_rust_code ... ok
test test_generate_stubs ... ok
test test_while_loop ... ok
test test_e2e_casts ... ok
test test_e2e_arrays ... ok
test test_e2e_destructor ... ok
test test_e2e_arrow_operator ... ok
test test_e2e_multiple_inheritance ... ok
test test_e2e_nullptr ... ok
test test_e2e_const_methods ... ok
test test_e2e_comma_operator ... ok
test test_e2e_generic_lambda ... ok
test test_e2e_deref_operator ... ok
test test_e2e_global_var ... ok
test test_e2e_inheritance ... ok
test test_e2e_namespaces ... ok
test test_e2e_for_loop ... ok
test test_e2e_subscript_operator ... ok
test test_e2e_pointers ... ok
test test_e2e_range_for ... ok
test test_e2e_global_array ... ok
test test_e2e_switch ... ok
test test_e2e_while_loop ... ok
test test_e2e_virtual_diamond ... ok
test test_e2e_enum_class ... ok
test test_e2e_default_params ... ok
test test_e2e_array_new_delete ... ok
test test_e2e_new_delete ... ok
test test_e2e_references ... ok
test test_e2e_namespace_path_resolution ... ok
test test_e2e_exception_handling ... ok
test test_e2e_struct_methods ... ok
test test_e2e_virtual_override ... ok
test test_e2e_lambda_basic ... ok
test test_e2e_ctor_body_stmts ... ok
test test_e2e_assignment_operators ... ok
test test_e2e_lambda_captures ... ok
test test_e2e_typedef ... ok
test test_e2e_factorial ... ok
test test_e2e_simple_add ... ok
test test_e2e_operator_overloading ... ok
test test_e2e_dynamic_dispatch ... ok
test test_e2e_base_constructor ... ok
test test_e2e_increment_decrement ... ok
test test_e2e_function_returning_struct ... ok
test test_e2e_functor ... ok
test test_e2e_nested_control ... ok
test test_e2e_static_members ... ok
test test_e2e_constructor ... ok
test test_e2e_copy_constructor ... ok

test result: ok. 54 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.99s


running 2 tests
test crates/fragile-clang/src/lib.rs - transpile_cpp_to_rust (line 34) ... ignored
test crates/fragile-clang/src/types.rs - types::CppType::substitute (line 417) ... ignored

test result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out; finished in 0.00s


=== Arrow Operator E2E Test ===
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// Helper for C++ new[] / delete[] with size tracking
#[inline]
unsafe fn fragile_new_array<T: Clone>(len: usize, init: T) -> *mut T {
    let align = std::mem::align_of::<T>().max(std::mem::align_of::<usize>());
    let header_size = std::mem::size_of::<usize>();
    let padding = (align - (header_size % align)) % align;
    let offset = header_size + padding;
    let elem_size = std::mem::size_of::<T>();
    let total_size = offset + elem_size.saturating_mul(len);
    let layout = std::alloc::Layout::from_size_align(total_size, align).unwrap();
    let base = std::alloc::alloc(layout);
    if base.is_null() { std::alloc::handle_alloc_error(layout); }
    let header = base as *mut usize;
    *header = len;
    let data = base.add(offset) as *mut T;
    for i in 0..len {
        std::ptr::write(data.add(i), init.clone());
    }
    data
}

#[inline]
unsafe fn fragile_delete_array<T>(ptr: *mut T) {
    if ptr.is_null() { return; }
    let align = std::mem::align_of::<T>().max(std::mem::align_of::<usize>());
    let header_size = std::mem::size_of::<usize>();
    let padding = (align - (header_size % align)) % align;
    let offset = header_size + padding;
    let base = (ptr as *mut u8).sub(offset);
    let len = *(base as *mut usize);
    for i in 0..len {
        std::ptr::drop_in_place(ptr.add(i));
    }
    let elem_size = std::mem::size_of::<T>();
    let total_size = offset + elem_size.saturating_mul(len);
    let layout = std::alloc::Layout::from_size_align(total_size, align).unwrap();
    std::alloc::dealloc(base, layout);
}

/// C++ class `Inner`
#[repr(C)]
#[derive(Default)]
pub struct Inner {
    pub value: i32,
}

impl Inner {
    pub fn new_0() -> Self {
        Self {
            value: 42i32,
        }
    }
    
    pub fn getValue(&self, ) -> i32 {
        return self.value;
    }
    
}

/// C++ class `SmartPtr`
#[repr(C)]
#[derive(Default)]
pub struct SmartPtr {
    pub ptr: *mut Inner,
}

impl SmartPtr {
    pub fn new_0() -> Self {
        Self {
            ptr: Box::into_raw(Box::new(Inner::new_0())),
        }
    }
    
    pub fn op_arrow(&self, ) -> *mut Inner {
        return self.ptr;
    }
    
}

impl Drop for SmartPtr {
    fn drop(&mut self) {
        drop(unsafe { Box::from_raw(self.ptr) });
    }
}

/// C++ function `main`
/// Mangled: `main`
pub fn cpp_main() -> i32 {
    let mut sp: SmartPtr = SmartPtr::new_0();
    if unsafe { (*sp.op_arrow()).value } != 42i32 {
        return 1i32;
    }
    if unsafe { (*sp.op_arrow()).getValue() } != 42i32 {
        return 2i32;
    }
    unsafe { (*sp.op_arrow()).value = 100i32 };
    if unsafe { (*sp.op_arrow()).value } != 100i32 {
        return 3i32;
    }
    return 0i32;
}

fn main() {
    std::process::exit(cpp_main());
}


